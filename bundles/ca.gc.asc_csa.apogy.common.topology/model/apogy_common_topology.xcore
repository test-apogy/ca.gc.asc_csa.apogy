/*
 * Copyright (c) 2016 Canadian Space Agency (CSA) / Agence spatiale canadienne (ASC).
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Pierre Allard (Pierre.Allard@canada.ca), 
 *     Regent L'Archeveque (Regent.Larcheveque@canada.ca),
 *     Sebastien Gemme (Sebastien.Gemme@canada.ca),
 *     Canadian Space Agency (CSA) - Initial API and implementation
 */
@GenModel(prefix="ApogyCommonTopology",
		  childCreationExtenders="true",
	      extensibleProviderFactory="true",
	      multipleEditorPages="false",
	      copyrightText="Copyright (c) 2016 Canadian Space Agency (CSA) / Agence spatiale canadienne (ASC).
All rights reserved. This program and the accompanying materials
are made available under the terms of the Eclipse Public License v1.0
which accompanies this distribution, and is available at
http://www.eclipse.org/legal/epl-v10.html

Contributors:
    Pierre Allard (Pierre.Allard@canada.ca), 
    Regent L'Archeveque (Regent.Larcheveque@canada.ca),
    Sebastien Gemme (Sebastien.Gemme@canada.ca),
    Canadian Space Agency (CSA) - Initial API and implementation",
	      modelName="ApogyCommonTopology",
	      suppressGenModelAnnotations="false")
@GenModel(modelDirectory="/ca.gc.asc_csa.apogy.common.topology/src-generated")
@GenModel(editDirectory="/ca.gc.asc_csa.apogy.common.topology.edit/src-generated")

package ca.gc.asc_csa.apogy.common.topology

import ca.gc.asc_csa.apogy.common.math.Tuple3d
import ca.gc.asc_csa.apogy.common.math.Matrix3x3

type Matrix4d wraps javax.vecmath.Matrix4d
type EClass wraps org.eclipse.emf.ecore.EClass
type INodeVisitor wraps ca.gc.asc_csa.apogy.common.topology.INodeVisitor

type Collection<T> wraps java.util.Collection
type List<T> wraps java.util.List

interface TopologyProvider
{
	refers readonly GroupNode topologyRoot
}

/**
 * The base class of all nodes in a topology.
 */
abstract class Node
{
	/** The parent of the node. */
	@GenModel(notify="true", propertyCategory="NODE")
	refers Node parent
	
	/** The description of the node. */
	@GenModel(notify="true", propertyCategory="NODE")
	String description
	
	/** The node identifier.*/
	@GenModel(notify="true", propertyCategory="NODE")
	String nodeId
		
	op void accept(INodeVisitor visitor)
}

class Link extends Node
{
	refers Node node
}

class Leaf extends Node
{
	
}

class URLNode extends Leaf
{
	String url
	
	int polygonCount
	
	int vertexCount
}
class CADNode extends URLNode
{
	String nodeName
}

class ContentNode<T> extends Leaf
{
	contains T content
}

class ReferencedContentNode<T> extends ContentNode<T>
{
	refers T referencedContent
}

class AggregateContentNode<T> extends ContentNode<T>
{
	contains T aggregateContent
}

class GroupNode extends Node
{
	@GenModel(children="false", createChild="false")
	contains Node [0..*] children
}

class ReferencedGroupNode extends GroupNode
{
	@GenModel(children="true", createChild="false")
	refers Node [0..*] referencedChildren
}

class AggregateGroupNode extends GroupNode
{
	@GenModel(children="true", createChild="true")
	contains Node [0..*] aggregatedChildren
}

class PositionNode extends AggregateGroupNode
{	
 	@GenModel(children="false", createChild="false")
	contains Tuple3d position
}

class RotationNode extends AggregateGroupNode
{
	@GenModel(children="false", createChild="false")
	contains Matrix3x3 rotationMatrix
}
	 

class TransformNode extends PositionNode, RotationNode
{
	op Matrix4d asMatrix4d()
	
	op void setTransformation(Matrix4d matrix)
}

class PickAndPlaceNode extends TransformNode
{
	
}

class ApogyCommonTopologyFacade
{
	/**
	 * Creates a Link node that point to a specified Node.
	 * @param node The node the Link point to.
	 * @return The Link node created.
	 */
	op Link createLink(Node node)
	
	/**
	 * Creates a ContentNode that contains a specified content.
	 * @param content The content of the node.
	 * @return The ContentNode created.
	 */
	op <T> ContentNode<T> createContentNode(T content)
	
	/**
	 * Creates a ReferencedContentNode that refers to a specified content.
	 * @param content The content the node is to refer to.
	 * @return The ReferencedContentNode created.
	 */
	op <T> ReferencedContentNode<T> createReferencedContentNode(T content)
	
	/**
	 * Creates a AggregateContentNode that contains a specified content.
	 * @param content The content of the node.
	 * @return The AggregateContentNode created.
	 */
	op <T> AggregateContentNode<T> createAggregateContentNode(T content)
	
	/**
	 * Creates a PositionNode with x,y,and z coordinates.
	 * @param x the position along the x axis.
	 * @param y the position along the y axis.
	 * @param z the position along the z axis.
	 */
	op PositionNode createPositionNode(double x, double y, double z)
	
	/*
	 * Creates a rotation node with the rotation order
	 * x*y*z
	 * 
	 * @param x
	 *            the rotation around the x axis, in radians.
	 * @param y
	 *            the rotation around the y axis, in radians.
	 * @param z
	 *            the rotation around the z axis, in radians.
	 */
	op RotationNode createRotationNodeXYZ(double x, double y, double z)
	
	/*
	 * Creates a rotation node with the rotation order
	 * y*z*x
	 * 
	 * @param x
	 *            the rotation around the x axis, in radians.
	 * @param y
	 *            the rotation around the y axis, in radians.
	 * @param z
	 *            the rotation around the z axis, in radians.
	 */
	op RotationNode createRotationNodeYZX(double x, double y, double z)
	
	/*
	 * Creates a rotation node with the rotation order
	 * z*y*x
	 * 
	 * @param x
	 *            the rotation around the x axis, in radians.
	 * @param y
	 *            the rotation around the y axis, in radians.
	 * @param z
	 *            the rotation around the z axis, in radians.
	 */
	op RotationNode createRotationNodeZYX(double x, double y, double z)
	
	/*
	 * Creates a transformation node with the rotation
	 * order x*y*z
	 * 
	 * @param tx
	 *            the x translation.
	 * @param ty
	 *            the y translation.
	 * @param tz
	 *            the z translation.
	 * @param rx
	 *            the rotation around the x axis, in radians.
	 * @param ry
	 *            the rotation around the y axis, in radians.
	 * @param rz
	 *            the rotation around the z axis, in radians.
	 */
	op TransformNode createTransformNodeXYZ(double tx, double ty, double tz, double rx, double ry, double rz)
	
	/*
	 * Creates a transformation node with the rotation
	 * order y*z*x
	 * 
	 * @param tx
	 *            the x translation.
	 * @param ty
	 *            the y translation.
	 * @param tz
	 *            the z translation.
	 * @param rx
	 *            the rotation around the x axis, in radians.
	 * @param ry
	 *            the rotation around the y axis, in radians.
	 * @param rz
	 *            the rotation around the z axis, in radians.
	 */
	op TransformNode createTransformNodeYZX(double tx, double ty, double tz, double rx, double ry, double rz)
	
	/*
	 * Creates a transformation node with the rotation
	 * order z*y*x
	 * 
	 * @param tx
	 *            the x translation.
	 * @param ty
	 *            the y translation.
	 * @param tz
	 *            the z translation.
	 * @param rx
	 *            the rotation around the x axis, in radians.
	 * @param ry
	 *            the rotation around the y axis, in radians.
	 * @param rz
	 *            the rotation around the z axis, in radians.
	 */
	op TransformNode createTransformNodeZYX(double tx, double ty, double tz, double rx, double ry, double rz)
	
	/**
	 * Creates a TransformNode using a pose expressed as a Matrix4d (4x4 matrix).
	 * @param matrix The matrix.
	 * @result The TransformNode created.
	 */
	op TransformNode createTransformNode(Matrix4d matrix)
	
	/**
	 * Creates a PickAndPlaceNode using a pose expressed as a Matrix4d (4x4 matrix).
	 * @param matrix The matrix.
	 * @result The PickAndPlaceNode created.
	 */
	op PickAndPlaceNode createPickAndPlaceNode(Matrix4d matrix)
	
	/**
	 * Return the 4x4 matrix expressing the pose of a specified Node in its root node.
	 * @param node The specified Node.
	 * @return The pose.
	 */
	op Matrix4d expressNodeInRootFrame(Node node)
	
	/**
	 * Return the 4x4 matrix expressing the pose of a Node's root in that Node reference.
	 * @param node The specified Node.
	 * @return The pose.
	 */
	op Matrix4d expressRootInNodeFrame(Node node)
	 
	/*
	 * Compute the transformation to express sourceFrame
	 * into targetFrame.
	 * <p>
	 * For example
	 * <ul>
	 * <li>sourceFrame could be laser scanner</li>
	 * <li>targetFrame could be the sonar sensor</li>
	 * </ul>
	 * This method can be used to express the point cloud coming out of the
	 * laser scanner in the frame of the sonar sensor.
	 * </p>
	 */
	op Matrix4d expressInFrame(Node sourceFrame, Node targetFrame)
	
	/**
	 * Returns all Node for which the description matches a specified string.
	 * @param description The description to match.
	 * @param root The root node of the topology.
	 * @return The list of matching Nodes.
	 */
	op Node[] findNodesByDescription(String description, Node root)
	
	/**
	 * Returns all Node for which the Id matches a specified string.
	 * @param nodeId The Id to match.
	 * @param root The root node of the topology.
	 * @return The list of matching Nodes.
	 */
	op Node[] findNodesByID(String nodeId, Node root)
	
	/**
	 * Returns all Node that are matches or are sub-classes of a specified EClass.
	 * @param clazz The EClass to match.
	 * @param root The root node of the topology.
	 * @return The list of matching Nodes.
	 */
	op Node[] findNodesByType(EClass clazz, Node root)
	
	/**
	 * Returns the root node (i.e. moves up the topology tree until the ultimate parent node is found) of a specified Node.
	 * @param node The specified Node.
	 * @return The root Node.
	 */
	op Node findRoot(Node node)
	
	/**
	 * Returns whether or not two specified Nodes shared the same topology tree.
	 * @param node1 The first Node.
	 * @param node2 The second Node.
	 * return True if the nodes share the same root Node.
	 */
	op boolean doNodesShareTopologyTree(Node node1, Node node2)
	
	/**
	 * Finds the list of Node that connects fromNode to toNode.
	 * @param fromNode The node from which to start.
	 * @param toNode The destination node.
	 * @return The list of nodes connecting fromNode to toNode. Never null.
	 */
	op List<Node> findNodePath(Node fromNode, Node toNode)
	
	/**
	 * Returns the Euclidian (i.e. straight line) distance between two Nodes. The nodes must be part of a common topology tree.
	 * @param fromNode The first Node.
	 * @param fromNode The second Node.
	 * return The distance between the specified Nodes, NaN if the specified node do no share the same topology tree.
	 */
	op double getEuclideanDistance(Node fromNode, Node toNode)
	
	/**
	 * Returns the geodesic (i.e. along the connecting edges) distance between two Nodes. The nodes must be part of a common topology tree.
	 * @param fromNode The first Node.
	 * @param fromNode The second Node.
	 * return The distance between the specified Nodes, NaN if the specified node do no share the same topology tree.
	 */
	op double getGeodesicDistance(Node fromNode, Node toNode)
	
	/**
	 * Prints the topology as text to the console.
	 * @param root The root node of the topology.
	 */
	op void printTopology(Node root)
	
	/*
	 * Applies a NodfeFilter to a list of Nodes.
	 * @param filter The filter to apply.
	 * @param nodes The list of Nodes on which to apply the filter.
	 * @return The list of Node that passes through the filter.
	 */
	op Collection<Node> filter(NodeFilter filter, Collection<Node> nodes)
}

/*
 * Abstract base class of all Node filters.
 */
abstract class NodeFilter
{
	/*
	 * Determines whether or not a specified Node should pass through the filter.
	 * @param nodes The list of Nodes on which to apply the filter.
	 * @return True if the Node satisfies the filter conditions, false otherwise.
	 */
	op boolean matches(Node node)
}

/**
 * NodeFilter based on a chain of filter. 
 */
class NodeFilterChain extends NodeFilter
{
	FilterChainType filterChainType = "AND"
	contains NodeFilter[0..*] filters
}

/**
 * The types of NodeFilterChain.
 */
enum FilterChainType
{
	/**
	 * All filter must matches for the Node to pass through.
	 */
	AND as "AND" = 0,
	/**
	 * At least one filter must matches for the Node to pass through.
	 */
	OR as "OR" = 1
}

/**
 * Node filter that filters Node based on their class type.
 */
class NodeTypeFilter extends NodeFilter
{
	/**
	 * The class to match.
	 */
	EClass clazz
}

/*
 * Base class for NodeFilter that use a regular expression matching as the way to determine if a node passes the filter.
 */
abstract class RegexNodeFilter extends NodeFilter
{
	/*
	 * The string representing the regular expression that needs to be matched.
	 */
	String regex
}

/**
 * A Node filter that filters Node based on their nodeId.
 */
class NodeIdFilter extends RegexNodeFilter
{
}

/**
 * A Node filter that filters Node based on their description field.
 */
class NodeDescriptionFilter extends RegexNodeFilter
{
}