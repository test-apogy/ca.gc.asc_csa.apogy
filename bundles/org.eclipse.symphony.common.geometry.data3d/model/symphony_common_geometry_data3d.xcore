@GenModel(prefix="Symphony__CommonGeometryData3D",
	      childCreationExtenders="true",
	      extensibleProviderFactory="true",
	      multipleEditorPages="false",
	      copyrightText="Canadian Space Agency / Agence spatiale canadienne 2015 Copyrights (c)",
	      modelName="Symphony__CommonGeometryData3D",
	      suppressGenModelAnnotations="false")
@GenModel(modelDirectory="/org.eclipse.symphony.common.geometry.data3d/src-generated")
@GenModel(editDirectory="/org.eclipse.symphony.common.geometry.data3d.edit/src-generated")

package org.eclipse.symphony.common.geometry.data3d

import org.eclipse.symphony.common.geometry.data.Polygon
import org.eclipse.symphony.common.geometry.data.PolygonSamplingShape
import org.eclipse.symphony.common.geometry.data.Coordinates
import org.eclipse.symphony.common.geometry.data.CoordinatesSet
import org.eclipse.symphony.common.geometry.data.Mesh
import org.eclipse.symphony.common.geometry.data.CoordinatesSamplingShape
import org.eclipse.symphony.common.geometry.data.CoordinatesSetShapesSampler
import org.eclipse.symphony.common.geometry.data.MeshPolygonShapesSampler
import org.eclipse.symphony.common.geometry.data.MeshCoordinatesShapesSampler

import org.eclipse.symphony.common.processors.Processor

type Vector2d wraps javax.vecmath.Vector2d
type Vector3d wraps javax.vecmath.Vector3d
type Point3d wraps javax.vecmath.Point3d
type Matrix4d wraps javax.vecmath.Matrix4d
type GVector wraps javax.vecmath.GVector
type List<T> wraps java.util.List
type Map<K, V> wraps java.util.Map
type Set<T> wraps java.util.Set
type SortedSet<T> wraps java.util.SortedSet
type Collection<T> wraps java.util.Collection
type EList<T> wraps org.eclipse.emf.common.util.EList
type IProgressMonitor wraps org.eclipse.core.runtime.IProgressMonitor
type OutputStream wraps java.io.OutputStream
type InputStream wraps java.io.InputStream
type IOException wraps java.io.IOException
type Exception wraps java.lang.Exception
type IllegalArgumentException wraps java.lang.IllegalArgumentException
type DoubleArrayOfArray wraps double[][]
type IntArray wraps int[]

/**
 * Identifies an axis of the Cartesian frame of reference.
 */
enum CartesianAxis
{
	X as "X" = 0,
	Y as "Y" = 1,
	Z as "Z" = 2
}

/**
 * Identifies a plane of the Cartesian frame of reference.
 */
enum CartesianPlane
{
	XY as "XY" = 0,
	XZ as "XZ" = 1,
	YZ as "YZ" = 2
}

/**
 * A polygon having Cartesian position as its vertices.
 */
class CartesianPolygon extends Polygon<CartesianPositionCoordinates>
{
	/**
	 * The surface of the polygon.
	 */
	@GenModel(notify="true", children="false", symphony_units="mÂ²")
	transient readonly volatile derived double surface
	
	/**
	 * The normal of the polygon.
	 */
	transient readonly volatile derived Vector3d normal
	
	/**
	 * The centroid of the polygon.
	 */
	refers readonly transient volatile derived CartesianPositionCoordinates centroid
}

/**
 * A Cartesian polygon that has exactly 3 vertices.
 */
class CartesianTriangle extends CartesianPolygon
{
	
}

class SphericalPolygon extends Polygon<SphericalCoordinates>
{
	
}

class SphericalTriangle extends SphericalPolygon
{
	
}

/**
 * A specialization of Coordinates that defines Cartesian coordinates.
 */
class CartesianPositionCoordinates extends Coordinates
{	
	@GenModel(notify="true", children="false", symphony_units="m")
	double x
	
	@GenModel(notify="true", children="false", symphony_units="m")
	double y
	
	@GenModel(notify="true", children="false", symphony_units="m")
	double z
	
	/**
	 * Returns the position as a Point3d.
	 */
	op Point3d asPoint3d()
}

/**
 * A specialization of CartesianPositionCoordinates that assigns a color to the position.
 */
class ColoredCartesianPositionCoordinates extends CartesianPositionCoordinates
{
	/**
	 * The red component, between 0 and 255.
	 */
	byte red
	
	/**
	 * The green component, between 0 and 255.
	 */
	byte green
	
	/**
	 * The blue component, between 0 and 255.
	 */
	byte blue
}

/**
 * A specialization of Coordinates that represent an orientation as 3 Euler angles.
 */
class CartesianOrientationCoordinates extends Coordinates
{
	@GenModel(notify="true", children="false", symphony_units="rad")
	double xRotation
	
	@GenModel(notify="true", children="false", symphony_units="rad")
	double yRotation
	
	@GenModel(notify="true", children="false", symphony_units="rad")
	double zRotation
}

class AbstractCartesianCoordinatesSet<T extends CartesianPositionCoordinates> extends CoordinatesSet<T>
{
	/**
	 * Returns the extent of the point cloud.
	 */
	op CartesianCoordinatesSetExtent getExtent()
}

/**
 * A set containing CartesianPositionCoordinates. It represent a point cloud.
 */
class CartesianCoordinatesSet extends AbstractCartesianCoordinatesSet<CartesianPositionCoordinates>
{	
	
}

/**
 * A set containing ColoredCartesianPositionCoordinates. It represents a point cloud.
 */
class ColoredCoordinatesSet extends AbstractCartesianCoordinatesSet<ColoredCartesianPositionCoordinates>
{
		
}

/**
 * Class that defines the volumetric extent of a set of cartesian coordinates.
 */
class CartesianCoordinatesSetExtent
{
	@GenModel(notify="true", children="false", symphony_units="m")
	double xMin
	
	@GenModel(notify="true", children="false", symphony_units="m")
	double xMax
	
	@GenModel(notify="true", children="false", symphony_units="m")
	double yMin
	
	@GenModel(notify="true", children="false", symphony_units="m")
	double yMax
	
	@GenModel(notify="true", children="false", symphony_units="m")
	double zMin
	
	@GenModel(notify="true", children="false", symphony_units="m")
	double zMax
	
	@GenModel(notify="true", children="false", symphony_units="m")
	transient readonly volatile derived double xDimension
	
	@GenModel(notify="true", children="false", symphony_units="m")
	transient readonly volatile derived double yDimension
	
	@GenModel(notify="true", children="false", symphony_units="m")
	transient readonly volatile derived double zDimension
}

class DigitalElevationMap extends CartesianCoordinatesSet
{
	int xDimension
	
	int yDimension
}

class CartesianCoordinatesMesh extends Mesh<CartesianPositionCoordinates, CartesianPolygon>,CartesianCoordinatesSet
{	
}

/**
 * Class representing a set of triangle defining a surface.
 */
class CartesianTriangularMesh extends Mesh<CartesianPositionCoordinates, CartesianTriangle>,CartesianCoordinatesSet
{	
}

/**
 * A spherical coordinate.
 * @see https://en.wikipedia.org/wiki/Spherical_coordinate_system
 */
class SphericalCoordinates extends Coordinates
{
	/**
	 * The azimuthal angle (about Z), in radians.
	 */
	@GenModel(notify="true", children="false", symphony_units="rad")
	double phi
	
	/**
	 * The polar angle, in radians.
	 */
	@GenModel(notify="true", children="false", symphony_units="rad")
	double theta
	
	/**
	 * The radius, in meters.
	 */
	@GenModel(notify="true", children="false", symphony_units="m")
	double r
}

class SphericalCoordinatesSet extends CoordinatesSet<SphericalCoordinates>
{
	
}

class SphericalCoordinatesMesh extends Mesh<SphericalCoordinates, SphericalPolygon>, SphericalCoordinatesSet
{
	
}

class SphericalTriangularMesh extends Mesh<SphericalCoordinates, SphericalTriangle>, SphericalCoordinatesSet
{
									  	
}

/**
 * Defines a full position and orientation in a Cartesian frame.
 */
class Pose extends CartesianPositionCoordinates, CartesianOrientationCoordinates
{
	
}

/**
 * A spherical sampling shape.
 */
class SphereSamplingShape<PolygonType extends CartesianPolygon> extends CoordinatesSamplingShape<CartesianPositionCoordinates>,
																		PolygonSamplingShape<CartesianPositionCoordinates, PolygonType>
{
	/**
	 * The radius of the sampling sphere, in meters.
	 */
	@GenModel(notify="true", children="false", symphony_units="m")
	double radius = "1.0"
	
	/**
	 * The position of the center of the sphere.
	 */
	refers CartesianPositionCoordinates center
	
	/**
	 * Whether or not to include polygon that have a vertex on the boundary.
	 */
	boolean includeJustTouching = "true"
}

/**
 * A Cube sampling shape.
 */
class CubeSamplingShape<PolygonType extends CartesianPolygon> extends CoordinatesSamplingShape<CartesianPositionCoordinates>,
																	  PolygonSamplingShape<CartesianPositionCoordinates, PolygonType>
{
	/**
	 * The position of the first corner defining the cube (or rectangular prism).
	 */
	refers CartesianPositionCoordinates corner1
	
	/**
	 * The position of the second corner defining the cube (or rectangular prism).
	 */
	refers CartesianPositionCoordinates corner2
	
	/**
	 * Whether or not to include polygon that have a vertex on the boundary.
	 */
	boolean includeJustTouching = "true"
}

class CartesianCoordinatesSetShapeSampler extends CoordinatesSetShapesSampler<CartesianPositionCoordinates>
{
	
}

class CartesianCoordinatesMeshSampler extends MeshCoordinatesShapesSampler<CartesianPositionCoordinates, CartesianPolygon>
{
	
}

class CartesianCoordinatesMeshPolygonSampler extends MeshPolygonShapesSampler<CartesianPositionCoordinates, CartesianPolygon>
{
	
}

class CartesianTriangularMeshSampler extends MeshCoordinatesShapesSampler<CartesianPositionCoordinates, CartesianTriangle>
{
	
}

class CartesianTriangularMeshPolygonSampler extends MeshPolygonShapesSampler<CartesianPositionCoordinates, CartesianTriangle>
{
	
}

class CartesianPositionCoordinatesMesher extends Processor<CartesianCoordinatesSet, CartesianTriangularMesh>
{
	
}

class NormalPointCloud
{
	List<Point3d> points
	
	List<Vector3d> normals
}

class PointLocator
{
	List<CartesianPositionCoordinates> points
	
	op CartesianPositionCoordinates findClosestPoint(CartesianPositionCoordinates point)
	
	op CartesianPositionCoordinates[] findPointsWithinRadius(double radius, CartesianPositionCoordinates point)
}

class VecmathPointLocator
{
	List<Point3d> points
	
	op Point3d findClosestPoint(Point3d point)
	
	op Point3d[] findPointsWithinRadius(double radius, Point3d point)
	
	op int findClosestPointId(Point3d point)
	
	op IntArray findPointIdsWithinRadius(double radius, Point3d point)
	
	op Point3d[] findClosestNPoints(Point3d referencePoint, int n)
	
	op IntArray findClosestNPointIds(Point3d referencePoint, int n)
}

class VecmathKdTreePointLocator extends VecmathPointLocator
{
	
}

/**
 * Class that provides an estimate of relative pose between two meshes, assuming the two meshes cove overlapping area of a surface. 
 */
class MeshLocalizer
{
	/*
	 * Localize a floating mesh with respect to a fixed mesh.
	 * The transform returned is the transform between the floating mesh and the origin (i.e. a revised version of the floatingMeshTransformEstimate).
	 * @param fixedMesh The mesh that is considered fixed.
	 * @param fixedMeshTransform The transform of the fixed mesh relative to a common reference frame.
	 * @param floatingMesh The mesh that is considered floating relative to the fixed one.
	 * @param floatingMeshTransformEstimate An starting estimate of the pose of the floating mesh relative to the common reference frame. 
	 */
	op Matrix4d localize(CartesianTriangularMesh fixedMesh, Matrix4d fixedMeshTransform, CartesianTriangularMesh floatingMesh, Matrix4d floatingMeshTransformEstimate) throws Exception
}

class PointNormalLocator
{
	refers NormalPointCloud dataSet
	
	op GVector findClosestPoint(Point3d point, Vector3d normal)
	
	op GVector[] findPointsWithinRadius(double radius, Point3d point, Vector3d normal)
	
	op GVector[] findClosestNPoints(int n, Point3d point, Vector3d normal)
	
	op int findClosestPointId(Point3d point, Vector3d normal)
	
	op IntArray findPointIdsWithinRadius(double radius, Point3d point, Vector3d normal)
	
	op IntArray findClosestNPointIds(int n, Point3d point, Vector3d normal)
}

/**
 * Mesher that uses the Quick Hull method to create a mesh from a point cloud. The algorithm is a three dimensional implementation of Quickhull by John E. Lloyd, as
 * described in Barber, Dobkin, and Huhdanpaa, <ahref=http://citeseer.ist.psu.edu/barber96quickhull.html> ``The Quickhull Algorithm for Convex Hulls''</a> (ACM Transactions on Mathematical Software, Vol. 22, No. 4, December 1996)
 * This implementation assumes that the meshing plane is XY.
 */
class DelaunayMesher extends CartesianPositionCoordinatesMesher
{	
	// TODO : Add the meshing plane as an attribute and take it into account in the implementation.
}

/**
 * Mesher for a DEM. 
 */
class DigitalElevationMapMesher extends Processor<DigitalElevationMap, CartesianTriangularMesh>
{	
}

/**
 * A sampler that resamples a DEM based on a configurable resolution. 
 */
class DigitalElevationMapSampler extends Processor<DigitalElevationMap, DigitalElevationMap>
{
	/**
	 * The target resolution of the DEM the sampler will return.
	 */
	@GenModel(notify="true", children="false", symphony_units="m")
	double targetResolution = "1.0"
}

class TriangularMeshNormalsCalculator extends Processor<CartesianTriangularMesh, CartesianTriangularMesh>
{	
}

class TriangularMeshToNormalPointCloud extends Processor<CartesianTriangularMesh, NormalPointCloud>
{	
}

/**
 * Filters out duplicate points from a point cloud.
 */
class UniquePointsFilter extends Processor<CartesianCoordinatesSet, CartesianCoordinatesSet>
{	
}

/**
 * Filters a triangular mesh based on the range of the triangle center relative to the origin and 
 * the length of the longest edge the triangle.
 */
class TriangleEdgeLengthTriangularMeshFilter
{
	/**
	 * The minimum range of the center of the triangle with respect to the origin. Triangles with their center closer
	 * to the origin than this value are filtered out.
	 */
	@GenModel(notify="true", children="false", symphony_units="m")
	double minimumRange
	
	/**
	 * The maximum range of the center of the triangle with respect to the origin. Triangles with their center further
	 * from the origin than this value are filtered out.
	 */
	@GenModel(notify="true", children="false", symphony_units="m")
	double maximumRange

	/**
	 * The maximum length of a edge that a triangle can have to pass the filter.
	 */	
	@GenModel(notify="true", children="false", symphony_units="m")
	double maximumEdgeLength
	
	/**
	 * Applies the filter to a triangular mesh.
	 * @param input The input triangular mesh.
	 * @return A triangular mesh containing only the triangles that passed the filter.
	 */
	op CartesianTriangularMesh filter(CartesianTriangularMesh input)
}

/**
 * Filters out point that a than a specified distance from any neighbor.
 */
class OutlierFilter extends Processor<CartesianCoordinatesSet, CartesianCoordinatesSet>
{
	/**
	 * The maximum distance a point can be from its closest neighbor an not be filtered out.
	 */
	@GenModel(notify="true", children="false", symphony_units="m")
	double maxDistance
}

/**
 * TODO duplicate of DigitalElevationMap ? Should move the methods to DigitalElevationMap.
 */
class RasterPointCloud
{
	int rows = "1"
	
	int columns = "1"
	
	op CartesianPositionCoordinates getPoint(int row, int column)
	
	op void setPoint(int row, int column, CartesianPositionCoordinates point)
}

/**
 * Should be removed when RasterPointCloud is integrated in DigitalElevationMap.
 */
class RasterPointCloudToCartesianCoordinatesSet extends Processor<RasterPointCloud, CartesianCoordinatesSet>
{	
}


/**
 * TODO : Define the algorithm used.
 */
class MeshSmoother extends Processor<CartesianCoordinatesSet, CartesianTriangularMesh>
{
	/**
	 * TODO : Defines what this does.
	 */
	int numberOfIterations = "1"
}

/*
 * This processor sub-samples a point cloud using a voxel approach based on an implementation of J. Bakambu from MDA. 
 */
class VoxelBased3DPointCloudResampler extends Processor<CartesianCoordinatesSet, CartesianCoordinatesSet>
{	
	/**
	 * Voxel resolution along the X axis.
	 */
	@GenModel(notify="true", children="false", symphony_units="m")
	double resolutionX = "0.1"
	
	/**
	 * Voxel resolution along the Y axis.
	 */
	@GenModel(notify="true", children="false", symphony_units="m")
	double resolutionY = "0.1"

	/**
	 * Voxel resolution along the Z axis.
	 */	
	@GenModel(notify="true", children="false", symphony_units="m")
	double resolutionZ = "0.05"
	
	/**
	 * Minimum number of points per voxel required to have a voxel considered occupied.
	 */
	int minimumNumberOfPointPerVoxel = "1"
	
	/**
	 * TODO : Define what this does.
	 */
	@GenModel(notify="true", children="false", symphony_units="m")
	double tileResolution = "5.0"
}

/**
 * A Cartesian position with an ID.
 */
class PositionMarker extends CartesianPositionCoordinates
{
	/**
	 * The identifier of the position.
	 */
	String identifier
}

/**
 * TODO
 */
class RigidBodyPoseTracker
{	
	/**
	 * The list of position markers for the rigid body at the origin.
	 */
	refers readonly derived PositionMarker [0..*] positionMarkersAtOrigin

	/**
	 * Adds a list of position marker to the one defining the rigid body.
	 * @param markers The list of position markers.
	 */
	op void addPositionMarkers(List<PositionMarker> markers) throws Exception
	
	/**
	 * Removes a list of position marker from the one defining the rigid body.
	 * @param markers The list of position markers.
	 */
	op void removePositionMarkers(List<PositionMarker> markers)

	/**
	 * This method computes the 3D rigid body transformation between two 3D data sets. First, the rotation matrix is computed using the Singular
	 * Values Decomposition (SVD) approach. Then, the translation component is computed. Finally, rotation and translation components are packed 
	 * into an homogenous 4x4 matrix. Note: At least 3 markers are required to solve the 3D pose. If more than 3 markers are specified, the best fit 
	 * (minimizing the root meaning square error) will be found.
	 * @param markerPositionsToTrack The list of position of the marker for which to find the body position.
	 * @return The position of the rigid body.
	 */
	op Point3d computeTransformation(EList<PositionMarker> markerPositionsToTrack) throws Exception
	
	/**
	 * Computes the 3D rigid body transformation between the markers defining the rigid body and a new set of the position markers.
	 * @param markerPositionsToTrack The list of position of the marker for which to find the body pose.
	 * @return The pose of the rigid body, represented as a 4x4 homogenous matrix.
	 */
	op Matrix4d computeTransformation(List<PositionMarker> markerPositionsToTrack) throws Exception
}


class Symphony__CommonGeometryData3DFacade
{	
	op CartesianPositionCoordinates createCartesianPositionCoordinates(double x, double y, double z)
	
	op CartesianOrientationCoordinates createCartesianOrientationCoordinates(double xRotation, double yRotation, double zRotation)
	
	op SphericalCoordinates createSphericalCoordinates(double phi, double theta, double r)

	op Pose createPose(double x, double y, double z, double xRotation, double yRotation, double zRotation)
	
	op Pose createPose(Pose pose)
	
	op Pose createPose(CartesianPositionCoordinates position, CartesianOrientationCoordinates orientation)
	
	op PointNormalLocator createPointNormalLocator(NormalPointCloud input)
	
	op DigitalElevationMap createDigitalElevationMap(CartesianCoordinatesSet coordinatesSet)
	
	op CartesianPolygon createCartesianPolygon(CartesianPositionCoordinates v1, CartesianPositionCoordinates v2, CartesianPositionCoordinates v3)
	
	op CartesianPositionCoordinates createCartesianPositionCoordinates(CartesianPositionCoordinates coordinates)
	
	op CartesianOrientationCoordinates createCartesianOrientationCoordinates(CartesianOrientationCoordinates coordinates)
	
	op CartesianCoordinatesMesh createCartesianCoordinatesMesh(CartesianCoordinatesMesh cartesianCoordinatesMesh)
	
	op CartesianTriangle createCartesianTriangle(CartesianPositionCoordinates v1, CartesianPositionCoordinates v2, CartesianPositionCoordinates v3)
	
	op <T extends CartesianPolygon> CartesianTriangle createCartesianTriangle(T polygon) throws IllegalArgumentException
	
	op CartesianCoordinatesMesh createCartesianCoordinatesMesh(List<CartesianPolygon> polygons)
	
	op CartesianCoordinatesMesh createCartesianCoordinatesMesh(CartesianTriangularMesh cartesianCoordinatesMesh)
	
	op CartesianTriangularMesh createCartesianTriangularMesh(List<CartesianTriangle> polygons)
	
	op CartesianTriangularMesh createCartesianTriangularMesh(CartesianTriangularMesh cartesianCoordinatesMesh)
	
	op CartesianCoordinatesSet applyTransform(CartesianCoordinatesSet points, Matrix4d trMatrix)
	
	op List<CartesianPositionCoordinates> applyTransform(List<CartesianPositionCoordinates> points, Matrix4d trMatrix)
	
	op CartesianTriangularMesh applyTransform(CartesianTriangularMesh mesh, Matrix4d trMatrix)
	
	op CartesianTriangularMesh applyTransformInt(CartesianTriangularMesh mesh, Matrix4d trMatrix)
	
	op NormalPointCloud applyTransform(NormalPointCloud points, Matrix4d trMatrix)
	
	op void updateCartesianCoordinatesSet(CartesianCoordinatesSet cartesianCoordinatesSet, DoubleArrayOfArray xyzData)
	
	op CartesianTriangularMesh concatenateTriangularMeshes(EList<CartesianTriangularMesh> listOfTriangularMeshes)
}

/**
 * Class defining methods used to save / load 3D data to / from files.
 */
class Data3DIO
{
	op CartesianTriangularMesh loadTriangularMesh(String file) throws IOException
	
	op CartesianTriangularMesh loadTriangularMesh(InputStream input) throws IOException
	
	op void saveTriangularMesh(CartesianTriangularMesh mesh, String file) throws IOException
	
	op void saveTriangularMesh(CartesianTriangularMesh mesh, OutputStream output) throws IOException
	
	op NormalPointCloud loadTriangularMeshFromASCIIAsNormalPointCloud(String filePrefix) throws IOException
	
	op CartesianTriangularMesh loadTriangularMeshFromASCII(String filePrefix) throws IOException
	
	op void saveTriangularMeshAsASCII(CartesianTriangularMesh mesh, String filePrefix) throws IOException
	
	op CartesianCoordinatesSet loadXYZ(String fileName) throws IOException
	
	op CartesianTriangularMesh loadTriangularMeshFromTriXYZ(String triFileName, String xyzFileName) throws IOException
	
	op void saveCoordinatesSetToXYZ(CartesianCoordinatesSet coordinatesSet, String file) throws IOException
	
	op void saveCoordinatesSetToXYZ(CartesianCoordinatesSet coordinatesSet, OutputStream file) throws IOException
	
	op void saveCoordinatesSetToCSV(CartesianCoordinatesSet coordinatesSet, String file) throws IOException
	
	op void saveCoordinatesSetToCSV(CartesianCoordinatesSet coordinatesSet, OutputStream file) throws IOException
}

class Data3DUtils
{
	op EList<Vector3d> computeNormals(CartesianTriangularMesh mesh)
	
	op CartesianPositionCoordinates computeCentroid(CartesianCoordinatesSet points)
	
	op void computeMinMaxValues(Point3d min, Point3d max, CartesianCoordinatesSet data)
	
	op double computeCurvatureChange(PointLocator pointLocator, int centerPoint, double radius)
	
	op double computeCurvatureChange(VecmathPointLocator pointLocator, int centerPoint, double radius)
	
	op CartesianTriangularMesh extrude(List<CartesianPositionCoordinates> profilePoints, CartesianAxis extrusionAxis, double extrusionWidth, boolean closeMesh)
}