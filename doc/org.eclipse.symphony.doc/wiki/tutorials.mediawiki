=Examples=

==PTU Dish Antenna==
==Camera==
==PTU Camera==
==Lander==
==Lidar==
==Mobile Platform==
==Robotic Arm==
==Rover (Complex Type)==

----

=Tutorials=

==I'm in a hurry! I want to operate a rover!!!==

==Getting Started Exercises==

===Setting Up A Symphony Environment===

====Creating A Symphony Session====

# Create a new ''Symphony Project'' named '''SymphonyTraining''';
# Create a new ''Symphony Session'' named '''MyFirstSession.'''

====Creating A Worksite====

# Under ''Symphony Environment'', create a new ''Worksites'';
# Under ''Worksites'', create a new ''Earth Surface Worksite'' named '''TrainingSite''';
# Delete the elements under ''Maps List'';
# Sets the ''X Axis Azimth'' to '''179.4 degrees''';
# Select the ''Symphony Environment'' and set its ''Active Worksite'' to '''TrainingSite''';
# Open the ''Symphony 3D Viewer'' and select the ''Symphony Environment''; 

====Creating Map Layers====

# Add a map named '''myMap''' to the ''TrainingSite's Map List'';
# Add a ''Cartesian Triangular Mesh URL Map Layer'' named '''myDEM''' to ''myMap'' with the following parameters:

{| class="wikitable"
! Parameter
! Value
|-
| Url
| platform:/plugin/org.eclipse.symphony.examples.worksites.surface/data/CSAAnalogTerrainDEM100cm.tri
|}

# Add a ''URL Image Map Layer'' named '''myContours''' to ''myMap'' with the following parameters:

{| class="wikitable"
! Parameter
! Value
|-
| Url
| platform:/plugin/org.eclipse.symphony.examples.worksites.surface/data/CSA-AT-contour-map-black-20cm-per-line.png
|-
| Height (m)
| 120.0
|-
| Width (m)
| 60.0
|}

# Add a ''Feature Of Interest Map Layer'' named '''myFOI''' to ''myMap'';
# Add a ''Feature Of Interest List'' as a child;
# Add the following ''Features Of Interest'' to that list:

{| class="wikitable"
! Name
! Position
|-
| Olympus Mons
| 33.5, 9.5, 2.6
|-
| Hill 937
| 33.0, 43.0, 0.3
|}

====Creating Variables & Contexts====

# In Session ''My First Session'', define a ''Variable'' named '''myRover''' of type ''SymphonySystemMobilePlatform''.
# Create two ''Contexts'':
## Context '''Simulated'''
## Context '''Real'''
# Set ''myRover'' to be implemented using '''MobilePlatformStub''' in the ''Simulated'' ''Context'';
# Set ''myRover'' to be implemented using '''MobilePlatformReal''' in the ''Real'' ''Context'';
# Set the session's ''activeContext'' to '''Simulated''';
# Instantiate the '''Variables''' (by using Symphony > Reset Instances.)

====Creating Data Products Sets====

# Set the name of the default ''Data Product Set'' to '''Simulated Data''';
# Create a new ''Data Product Set'' named '''Real Data''';
#* Create an ''Operation Call Results List'' under ''Real Data'';
# Assign '''Simulated Data''' to the ''Simulated'' ''Context'';
# Assign '''Real Data''' to the ''Real'' ''Context'';

===Issuing Commands===

====Invoking Operations On A Simple System====

# Under ''Programs'', create an ''Operation Calls'' program called '''myRoverCalls'''
# Create a call named '''Init''' to operation '''init()''' on ''myRover'';
# Create a call named '''Move''' to operation '''cmdLinearVelocity()''' on ''myRover'' with ''Parameter'' '''speed''' set to '''0.25''';
# Create a call named '''Stop''' to operation '''cmdLinearVelocity()''' on ''myRover'' with ''Parameter'' '''speed''' set to '''0.0''';
# Invoke Init by selecting "Symphony > Invoke"
# Invoke Move ("Symphony > Invoke") - the rover should start moving forward;
# Invoke Stop ("Symphony > Invoke") when you want to stop the rover.

====Using The Pose Corrector====

# Create an ''Operation Call'' named '''CommandVel''' to '''cmdVelocities(...)''' on ''myRover'' with the following ''Parameters'':

{| class="wikitable"
! Parameter
! Value
|-
| linearVelocity
| 1.5 (m/s)
|-
| angularVelocity
| 5.0 (deg/s)
|}

# Create an ''Operation Call'' named '''AllStop''' to '''cmdVelocities(...)''' on ''myRover'' with the following ''Parameters'':

{| class="wikitable"
! Parameter
! Value
|-
| linearVelocity
| 0.0 (m/s)
|-
| angularVelocity
| 0.0 (deg/s)
|}

# In the ''Session Editor'', expand the ''Active Context'' (''Simulated'');
# Expand the ''Variable Implementations'';
# Expand ''myRover'';
# Expand the ''API Adapter'' (''Mobile Platform Symphony System Api Adapter'');
# Right-click on the ''Vehicle Pose Corrector'' and select "Symphony > Enable/Disable Pose Corrector";
# Invoke ''CommandVel'' to move the rover
# When ready, invoke ''AllStop'' to stop it.

====Using Operation Call Controller Bindings====

=====Binding A Controller To Move The Rover Around=====

# Open the ''Controllers Status View'';
# Under ''Programs'', create a ''Controllers Configuration'' named '''myFirstCtrlConfig''
# Create an ''Operation Call Controller Binding'' named '''Velocity''' for the ''myRover'' ''Variable'' that binds the '''cmdVelocities(...)''' operation:
#* Create a ''TimeTrigger'' to get a periodic call at 10 Hz (every 100 ms)
# Map the ''linearVelocity'' parameter to a joystick input axis;
## Add a ''Centered Linear Input Conditioning with the following values:

{| class="wikitable"
! Parameter
! Value
|-
| Dead Band
| 0.1
|-
| Maximum
| -2.0
|-
| Minimum
| 2.0
|}

## Map the ''angularVelocity'' ''Parameter'' to a joystick inpit axis;
##* Add a ''Centered Linear Input Conditioning'' with the following values:

{| class="wikitable"
! Parameter
! Value
|-
| Dead Band
| 0.1
|-
| Maximum
| -0.5
|-
| Minimum
| 0.5
|}

# Activate the ''myFirstCtrlConfig'' and drive your rover around!

=====Binding A Controller To Move The Rover Around, With An Enabled Button=====

# Create another ''Controllers Configuration'' named '''mySecondCtrlConfig'''.
# Create an ''Operation Call Controller Binding'' named '''Velocity''' for the ''myRover'' ''Variable'' that binds the '''cmdVelocities(...)''' operation:
#* Create a ''State Trigger'' to get a periodic call at 10 Hz (every 100 ms) when a given joystick button is pressed (i.e. dead man's switch)
# Map the ''angularVelocity'' parameter to a joystick input axis;
## Add a ''Centered Linear Input Conditioning'' with the following values:

{| class="wikitable"
! Parameter
! Value
|-
| Dead Band
| 0.1
|-
| Maximum
| -2.0
|-
| Minimum
| 2.0
|}

## Map the ''linearVelocity'' parameter to a joystick input axis;
##* Add a ''Centered Linear Input Conditioning'' with the following values:

{| class="wikitable"
! Parameter
! Value
|-
| Dead Band
| 0.1
|-
| Maximum
| -0.5
|-
| Minimum
| 0.5
|}

# Activate the ''mySecondCtrlConfig'' and drive your rover around. '''''Does it work as expected?'''''

===Defining & Using Composite Types===

====The Target Assembly====
TODO!

====Defining A Composite System====

# Create a new ''Symphony System'' in ''Local Type'' named '''MyFirstAssembly'''
# Add three (3) ''Type Members'':
## '''rover''' of type ''SymphonySystemMobilePlatform'';
## '''camera''' of type ''SymphonySystemPTUCamera'';
## '''arm''' of type ''SymphonySystemRoboticArm''
# Add a ''Topology Root'' with a ''Transform Node'' child with its ''Node Id'' set to '''myFirstAssemblyRoot'''
# Under ''MyFirstAssembly'', create a ''Connection Points List''
# Under the new ''Connection Points List'', create a ''Connection Point'' named '''origin''', referring to the ''myFirstAssemblyRoot'' node.
# Under ''MyFirstAssembly'', create an ''Assembly Links List'';
# Create a first ''Assembly Link'' named '''assemblyToRover''':
## Set its ''Parent Connection Point'' to '''origin''';
## Set its ''Sub System Type Member'' to '''rover''';
# Create a second ''Assembly Link'' named ''roverToCamera'':
## Set its ''Parent Type Member'' to '''rover''';
## Set its ''Parent Connection Point'' to '''MOBILE_PLATFORM_SYM_SYS_CONNECT_MAST_CENTRE_PLATE''';
## Set its ''Sub System Type Member'' to '''camera''';
# Create a third ''Assembly Link'' named ''roverToArm'':
## Set its ''Parent Type Member'' to '''rover''';
## Set its ''Parent Connection Point'' to '''MOBILE_PLATFORM_SYM_SYS_CONNECT_ARM_MOUNT''';
## Set its ''Sub System Type Member'' to '''arm''';
# Set the ''Pose Provider'' of ''myFirstAssembly'' to '''rover''';
# Create a ''Variable'' named '''myAssembly''' of type ''MyFirstAssembly'';
# In the ''Active Context'', create a new ''Variable Implementation'':
## Assign its ''Variable'' to '''myAssembly''';
## Specify an implementation class for:
### ''rover'' -> '''MobilePlatformStub'''
### ''camera'' -> '''PTUCameraSimulated'''
### ''arm'' -> '''RoboticArmSimulated'''
# Reset Instances

====Invoking Operation On Composite System Type Members====

# Create an ''Operation Calls'' program called '''myAssemblyCalls''';
# Create a call named '''Init''' to operation ''init()'' on ''myAssembly:rover''
# Create a call named '''Move''' to operation ''cmdLinearVelocity(...)'' on ''myAssembly:rover'' with ''Parameter'' '''speed''' set to '''0.25''';
# Create a call named '''Stop''' to operation ''cmdLinearVelocity(...)'' on ''myAssembly:rover'' with ''Parameter'' '''speed''' set to '''0.0''';
# Invoke ''Init'';
# Invoke ''Move'' - the assembly should start moving forward;
# invoke ''Stop'', when you want to stop your assembly.

====Invoking Operation On A Feature Of Composite Type Members====

# Create a call named '''Power On''' to operation ''turnOn()'' on ''myAssembly:rover.powerSystem'';
# Invoke ''Power On''. 

===Setting Up & Using The Camera View===

====Configuring A Camera View====

# Create a ''Camera Configurations List'' under ''Tools'';
# Create a ''Camera Configuration'' named '''myCameraViewConfig''';
# Set the ''Variable'' and ''Camera'' to refer to the camera of ''myAssembly'' ('''myAssembly:camera''');
# Open the ''Camera View'' and then select ''myCameraViewConfig'';
# Create a call named '''acquireImage''' to operation ''takeSnapshot()'' on ''myAssembly:camera'';
# Invoke ''acquireImage''.

====Adding Overlays====

# Add an ''EMF Feature Overlay'' to display the current pan angle of the camera on the top left corner of the view:
## Create a ''Variable Feature Reference'', set the ''Variable'' to '''myAssembly''';
## Create a ''Type'' referring to ''camera'';
## Create a ''Feature'' chain referring to ''currentPanAngle'';
# Add a ''Gray Scale Filter'' to ''myCameraViewConfig'';
# Create a call named '''moveToPanTilt''' to operation ''moveToPanTilt(...)'' on ''myAssembly:camera'';
# Call ''acquireImage'' on ''camera'' to get the image to update;
# Call ''moveToPanTilt'' on ''camera'' to change the camera orientation;
# Call ''acquireImage'' again on ''camera'' to get the image to update. 

===Setting Up & Using The Map View===

====Displaying The Environment====

# Create a ''Map View Configuration List'' under ''Tools'';
# Create a ''Map View Configuration'' named '''myMapConfig''';
# Create an ''Image Map Layer Presentation'' referring to '''myContours'';
# Create a ''Feature Of Interest Map Layer Presentation'' referring to '''myFOI''';
# Open the ''Map View'' and select '''myMapConfig'''.

====Displaying The Variables====

# Create a ''Vehicle Variable Annotation'' referring to '''myRover''';
# Create a ''Variable Trajectory Annotation'':
## Create a ''Default Trajectory Provider'' as its child;
## Assign its ''Variable'' to '''myRover'';
## Close the Map View;
## Open the Map View and select '''myMapConfig'''.

===Setting Up & Using The Telemetry View===

====Defining Watches====

# Under ''Tools'', create a ''Watches List Container'';
# Under ''Watches List Container'', create a ''Watches List'' named '''Test''';
# Under '''Test''', create a ''Watch'' named '''armWatch''', assign its ''Variable'' to '''myAssembly'''
# Under '''armWatch''', create a ''Type Member Reference Tree'' referring to '''arm''';
# Under '''armWatch''', create a ''Type Root Node'' and set its ''Source Class'' to '''RoboticArm''';
# Create a chain of ''Tree Feature Nodes'' to finally refer to '''elbowAngle''' 

====Defining Displays====

# Under ''Tools'', create a new ''Displays'';
# Under ''Displays'', create a ''Display List'' named '''armDisplays''';
# Under '''armDisplays''', create a ''Text Display'' with its ''Abstract Feature Node'' referring to '''elbowAngle''';
# Under '''armDisplays''', create a ''Number Vs. Time Plot Display'' with its ''Abstract Feature Node'' referring to '''elbowAngle''', with its ''height'' set to '''200''' and its ''width'' set to '''200'''.
# Open the ''Telemetry View'' and select '''armDisplays'''.  

----

==Developing Your Own Custom Symphony Types==

===Creating & Symphonizing your own Pan Tilt Unit (PTU) Camera System===

====An Overview Of The Desired System====
TODO!

====1. Creating the PTU Camera's EMF Meta-Model====

=====i. Creating The Camera's EMF Model=====

# Create a new ''Xcore Project'' named '''<org_prefix>.ptu''', where <org_prefix> is replaced by an appropriate prefix for your organization.
# In the '''/model''' folder, create an Xcore model named '''ptu.xcore'''
# Copy the following to the start of the empty Xcore model, replacing <org_prefix> where required:

 <nowiki>@GenModel(prefix="PTUCamera",
 				   modelName="PTUCamera",
 				   childCreationExtenders="true",
				   extensibleProviderFactory="true",
	      		   multipleEditorPages="false",
	      		   operationReflection="true",
	      		   suppressGenModelAnnotations="false")
@GenModel(modelDirectory="/<org_prefix>.ptu/src-generated")
@GenModel(editDirectory="/<org_prefix>.ptu.edit/src-generated")

package <org_prefix>.ptu</nowiki>

# Create the class hierarchy shown before (classes in blue);
# Save the '''ptu.xcore''' file.  This will trigger the code generation in both the '''<org_prefix>.ptu''' and '''<org_prefix>.ptu.edit''' plugins.

=====ii. Implementing the Required Methods=====

# Implement the following methods in ''<org_prefix>.ptu.impl.CameraImpl'':

{| class="wikitable"
! Method
! Description
|-
| ''RectangularFieldOfView()'' getFov()
| Getter method for the ''fov'' attribute of the camera.  See the code provided.
|-
| ''boolean'' commandZoom(''double'' zoom)
| Configures the current zoom; this needs to update the FOV as well!  See the code provided.
|-
| ''double'' getMinimumZoom()
| Returns the minimum zoom factor.  Return '''1.0''';
|-
| ''double'' getMaximumZoom()
| Returns the maximum zoom factor.  Return '''10.0''';
|-
| ''RectangularFrustrumFieldOfView'' getFieldOfView()
| Method declared by ''AbstractCamera''.  Return getFov();
|}

# Implement the following methods in ''<org_prefix>.ptu.impl.CameraSimulatedImpl'':

{| class="wikitable"
! Method
! Description
|-
| ''boolean'' initialize()
| Initialize the camera.  Just return '''true''';
|-
| ''ImageSnapshot'' takeSnapshot()
| Takes and returns an ''ImageSnapshot''. See the code provided.
|}

# Implement the following methods in ''<org_prefix>.ptu.impl.PTUCameraSimulatedImpl'':

{| class="wikitable"
! Method
! Description
|-
| ''double'' getMaximumPanAngle()
| Returns the maximum pan angle ('''in radians''').  Just return 170.0 degrees.
|-
| ''double'' getMinimumPanAngle()
| Returns the minimum pan angle ('''in radians''').  Just return -170.0 degrees.
|-
| ''double'' getMaximumTiltAngle()
| Returns the maximum tilt angle ('''in radians''').  Just return 90.0 degrees.
|-
| ''double'' getMinimumTiltAngle()
| Returns the minimum tilt angle ('''in radians''').  Just return -45.0 degrees.
|-
| ''boolean'' moveToPan(''double'' panAngle)
| Checks the commanded pan angle, which is in '''radians'''.  If it's within range, update '''currentPan''' to the commanded value and return true; otherwise, return false.
|-
| ''boolean'' moveToTilt(''double'' tiltAngle)
| Checks the commanded tilt angle, which is in '''radians'''.  If it's within range, update '''currentTilt''' to the commanded value and return true; otherwise, return false. 
|-
| ''boolean'' moveToPanTilt(''double'' panAngle, ''double'' tiltAngle)
| Checks the commanded pan and tilt angles, both of which are in '''radians'''.  If they are within range, update both '''currentPan''' and '''currentTilt''' to the commanded values and return true; otherwise, return false.
|-
| ''boolean'' moveByPan(''double'' panAngleDelta)
| Checks the sum of '''currentPan''' and the commanded pan angle offset (given in '''radians''').  If the resulting pan angle is in range, update '''currentPan''' to the resultant value and return true; otherwise, return false. 
|-
| ''boolean'' moveByTilt(''double'' tiltAngleDelta)
| Checks the sum of '''currentTilt'''and the commanded tilt angle offset (given in '''radians''').  If the resulting tilt angle is in range, update '''currentTilt''' to the resultant value and return true; otherwise, return false. 
|-
| ''boolean'' moveByPanTilt(''double'' panAngleDelta, ''double'' tiltAngleDelta)
| Checks the sum of '''currentPan''' and the commanded pan angle offset (given in '''radians''') as well as the sum of '''currentTilt''' and the commanded tilt angle offset (given in '''radians''').  If both resulting angles are in range, update both '''currentPan''' and '''currentTilt''' to the resultant values and return true; otherwise, return false.
|-
| ''boolean'' stopMotion()
| Stops all motion.  Just return true.
|}

=====iii. Testing the System=====

# Create a new ''Eclipse Application'' under ''Run Configuration''. Name it '''TEST''';
# Click ''Run'' to launch another instance of Eclipse with your plugins;
# In the ''Project Explorer View'', create a new Symphony Project (by clicking on ''New > Other... > Symphony > New Symphony Project'').  Name it '''my_tests''';
# Create a new Symphony Session named '''MySession.sym''' in the newly create project.
# In the ''Types'', under ''Local'', create a ''Type'' named '''PTUCamera''';
# Set the type's ''Interface Class'' to ''<org_prefix>.ptu.PTUCamera'';
# Under ''Variables'', create a ''Variable'' named '''ptuCamera''' and specify its type as '''PTUCamera''';
# In the '''Default''' ''Context'', add a ''Variable Implementation'' that maps variable '''ptuCamera''' to a ''<org_prefix>.ptu.SimulatedPTUCamera'' implementation;
# Select the ''Symphony Environment'' and right-click, selecting ''Symphony > Reset Instances'' to initialize instances;
# Under ''Programs'', create an ''Operation Call List'' named '''ptuCmd''';
# Under ''ptuCmd'', create an ''Operation Call'' named '''Init'' referencing ''ptuCamera.initialize()'';
# Invoke the '''Init''' ''Operation Call'' and verify that the command has been executed;
# Under ''ptuCmd'', create an ''Operation Call'' named '''MoveTo''' referencing ''ptuCamera.moveToPanTilt(...)'', with a '''pan''' ''Parameter'' of '''45.0''' degrees and a '''tilt''' ''Parameter'' of '''-30.0''' degrees; 
# Invoke the '''MoveTo''' ''Operation Call'' and verify that the command has been executed;
# Under ''ptuCmd'', create an ''Operation Call'' named '''Zoom''' referencing ''ptuCamera.commandZoom(...)'', with a '''zoom''' ''Parameter'' of '''2.0''';
# Invoke the '''Zoom''' ''Operation Call'' and verify that the command has been executed;
# Under ''ptuCmd'', create an ''Operation Call'' named '''SnapShot''' referencing ''ptuCamera.takeSnapshot()''
# Invoke the '''SnapShot''' ''Operation Call'' and verify that the command has been executed.

====2. Creating the PTU Camera's Symphony Plugin====

=====i. Creating The Camera's Plugin Project=====
=====ii. Developing the Camera's Symphony Xcore (.xcore) model=====
=====iii. Specializing SymphonyInitializationData for the Camera=====
=====iv. Specializing SymphonySystemApiAdapter for the Camera=====

====3. Creating the PTU Camera's complete Symphony System Model====

=====i.Creating the Camera's Symphony System Model file=====
=====ii. Specifying the Camera's Topology=====

======Creating the CAD folder======
======Populating the topology======

=======Node hierarchy=======
=======Transformations=======

=====iii. Making the Camera's Bindings=====

======Defining the Feature Nodes======
======Making the Bindings themselves======

=====iv. Registering the Camera's Symphony System Model=====

====4. Testing the completed PTU Camera in Symphony====
