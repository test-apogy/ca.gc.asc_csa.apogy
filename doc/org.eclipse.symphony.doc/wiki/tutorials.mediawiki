= Symphony Examples & Tutorials =

== Table Of Contents ==
__TOC__

== Examples ==

Symphony provides a series of built-in example ''Systems'' to illustrate and highlight its numerous capabilities and features.  These ''Systems'', while fairly basic simulations of their real-world counterparts, show at a high level to design a ''System'' and integrate it into Symphony.  There are a large amount of variety in the examples, which include articulated and composite ''Systems''.  In addition, the examples leverage their respective ''Environment'' to facilitate the simulation.  As suggested in the guidelines, each of the example ''Systems'' have their EMF meta-models separate and distinct from their Symphony (System) plug-ins.  More than anything else, the examples highlight the recommended way to ''symphonynize'' any new ''System''.

The following examples are currently available in Symphony:

{| border="1" cellpadding="2"
! Symphony System
! Description
! Plugin
|-
| '''''PTUDishAntennaSymphonySystem'''''
| A simulated antenna dish mount on a pan-tilt unit (PTU).  Antenna is made to track the Sun based on the '''Worksite'' sky.
| ''org.eclipse.symphony.examples.antenna''
|-
| '''''CameraSymphonySystem'''''
| A simulated camera.
| rowspan="2" | ''org.eclipse.symphony.examples.camera''
|-
| '''''PTUCameraSymphonySystem'''''
| A simulated camera mounted on a pan-tilt unit (PTU).
|-
| '''''LanderSymphonySystem'''''
| A simulated lander.
| ''org.eclipse.symphony.examples.lander''
|-
| '''''LidarSymphonySystem'''''
| A simulated raster scan Lidar.
| ''org.eclipse.symphony.examples.lidar''
|-
| '''''MobilePlatformSymphonySystem'''''
| A simulated four-wheeled, skid-steered mobile platform.
| ''org.eclipse.symphony.examples.mobile_platform''
|-
| '''''RoboticArmSymphonySystem'''''
| A simulated robotic arm with four rotatable joints
| ''org.eclipse.symphony.examples.robotic_arm''
|-
| '''''RoverSymphonySystem'''''
| A simulated rover, which is a complex ''System'', composed of a ''Mobile Platform'', ''Robotic Arm'' and two ''Camera'' sub-<i>Systems</i>.
| ''org.eclipse.symphony.examples.rover''
|}

=== Example Specifics === 

Note: It is important to note that while all of the above example ''Systems'' only provide simulations, given Symphony's flexibility, it would be a simple matter to add a real-world implementation for all of them.

==== <i>PTU Dish Antenna</i> ====

This ''System'' refers to a conical antenna which is mounted on top of a pan-tilt unit (PTU).  The antenna has the capability to change the position that it is directed at, by manipulating the PTU's pan and tilt angles.  In fact, the antenna is capable to track and follow the position of the Sun in the sky.  

TODO!

==== <i>Camera</i> ====

This ''System'' refers to a basic camera.  This camera is only capable to changing its zoom level and taking snapshots of the environment.

TODO!

==== <i>PTU Camera</i> ====

This ''System'' refers to a slightly more advanced ''Camera'', which is mounted on top of a pan-tilt unit (PTU).  In addition to the basic capabilities described for the '''Camera''' ''System'', it is also capable of change the direction in which it is facing, by changing its PTU unit's pan and tilt angles appropriately.

TODO!

==== <i>Lander</i> ====

This ''System'' refers to a three-legged lander, with a thruster mounted under the bottom center of it.  The lander's three legs can be extended or retracted individually, allowing a variety of possible configurations. The amount of thrust exerted by the lander's thruster is controllable (within a range) and as such, the lander IS capable of flight; it however, rather tricky to control, especially when dealing with angular velocity.

TODO!

==== <i>Lidar</i> ====

This ''System'' refers to a raster scan Lidar unit.  This ''System'' has a fixed position and is only capable of acquiring Lidar scans. 

TODO!

==== <i>Mobile Platform</i> ====

This ''System'' refers to a four-wheeled, movable platform, upon which other ''Systems'' could be attached.  This ''System'' can control its linear and angular velocities, allowing it to move around the ''Environment''.

TODO!

==== <i>Robotic Arm</i> ====

This ''System'' refers to an articulated robotic arm with four different joints:
# '''Turret'''
# '''Shoulder'''
# '''Elbow'''
# '''Wrist'''
By changing the angles of its various joints, it can change its configuration as specified.

TODO!

==== <i>Rover</i> (Complex System) ====

This ''System'' refers to a Composite or ''Complex System'' that contains four different sub-''Systems'':
# ''Mobile Platform'' - To facilitate the rover's movement
# ''Robotic Arm'' - To permit the rover to interact with the environment
# Arm ''PTU Camera'' - To allow capture of images from the ''Robotic Arm''
# Center ''PTU Camera'' - To allow capture of images from the center of the ''Mobile Platform''
The ''Rover'' combines all of these ''Systems'' to leverage all of their capabilities into one multi-purpose ''System''.

TODO!

=== <i>Registered Symphony Projects</i> ===

In order to make it simpler to get started, Symphony provide a '''Registered Symphony Project''' for each of the examples.  The primary component of each of these ''Symphony Projects'' is the '''session.sym''' file; this defines a sample ''Session'' that highlights the various features of that example.  Each of these ''Sessions'' is designed to be fully usable as is; this allowing one to literally use it and see the example in action without having to add or change anything.  In particular, they already have the following specified:

* ''Variable(s)''
* ''Contexts''
* ''Worksites''
* ''Time Sources''
* ''Programs'' with sample ''Operation Calls''
* ''Data Product Sets''
* Any required ''Tools''

These ''Projects'' not only make it easy to use the examples, they are also valuable references when developing and using new ''Systems''.

==== Importing a <i>Symphony Project</i> ==== 

In order to import a ''Registered Symphony Project'', one can simply:

# Right-click on the ''Project Explorer'' and select "''New > Project...''";
# Select "''Symphony > New Symphony Project''" and click "''Next >''";
# In the wizard that appears:
#* Enter the desired name for the new project ;
#* Check the "'''Import Registered Symphony Project'''" check box;
#* Click "''Next >''";
# Select the desired ''Sample Registered Project'' (e.g. '''Mobile Platform Example''' to highlight the usage of the ''MobilePlatformSymphonySystem'');
# Click "''Finish''" to complete the import process.

----

== Tutorials ==

The following tutorials provide hands-on training of Symphony.  The goal of the training is to give the first-hand experience of Symphony as both a user and a developer; this will give a far deeper grasp of how best Symphony can be applied in various scenarios. 

=== Simplest Way To Start ===

The examples are a simple way to get started interacting with Symphony and seeing what it can do.  As laid out in the ''Registered Symphony Projects'' section above, it's easy to start using Symphony ''Systems''; by doing so, one can gain a foundation for the material and better understanding for how Symphony and its various components operate.

=== Getting Started Exercises ===

The following user-oriented exercises are geared towards providing a providing familiarity with Symphony ''Sessions''.  By the end of the session, one should be able to:

* set up a complete ''Symphony Environment'';
* issue commands to a ''System'';
* work with Composite ''Types'';
* set up the ''Camera View''
* set up the ''Map View''

==== Setting Up A <i>Symphony Environment</i> ====

The following exercises are focused on the creating and fully setting up a ''Session'' and in particular, the ''Symphony Environment''.  By the end of this session, one should be able to:

* create a Symphony ''Session''
* create a ''Worksite''
* create ''Map Layers''
* create ''Variables'' & ''Contexts''
* create ''Data Product Sets''

===== Creating A Symphony <i>Session</i> =====

<ol>
	<li> Right-click on the ''Project Explorer'' and select "''New > Project...''";</li>
	<li> Select "''Symphony > New Symphony Project''" and click "''Next >''";</li>
	<li> In the wizard that appears:</li>
	<ol type="i">
		<li> Enter '''SymphonyTraining''' for the name of the new project;</li>
		<ul>
			<li> Ensure that the "'''Import Registered Symphony Project'''" check box is '''not''' checked;</li>
		</ul>
		<li> Click "''Next >''";</li>
		<li> Uncheck all of the check boxes on the following screen;</li>
		<li> Enter '''MyFirstSession.sym''' for the name of the new ''Session''.</li>
		<li> Click "''Finish''";</li>
	</ol>
</ol>

===== Creating A <i>Worksite</i> =====

# Under ''Symphony Environment'', create a new ''Worksites'';
# Under ''Worksites'', create a new ''Earth Surface Worksite'' named '''TrainingSite''';
# Delete the elements under ''Maps List'';
# Sets the ''X Axis Azimth'' to '''179.4 degrees''';
# Select the ''Symphony Environment'' and set its ''Active Worksite'' to '''TrainingSite''';
# Open the ''Symphony 3D Viewer'' and select the ''Symphony Environment''; 

===== Creating <i>Map Layers</i> =====

<ol>
	<li> Add a map named '''myMap''' to the ''TrainingSite's Map List'';</li>
	<li> Add a ''Cartesian Triangular Mesh URL Map Layer'' named '''myDEM''' to ''myMap'' with the following parameters:</li>
</ol>

{| border="1" cellpadding="2" style="margin-left: 30px;"
! Parameter
! Value
|-
| ''Url''
| '''platform:/plugin/org.eclipse.symphony.examples.worksites.surface/data/CSAAnalogTerrainDEM100cm.tri'''
|}

<ol start="3">
	<li> Add a ''URL Image Map Layer'' named '''myContours''' to ''myMap'' with the following parameters:</li>
</ol>

{| border="1" cellpadding="2" style="margin-left: 30px;"
! Parameter
! Value
|-
| ''Url''
| '''platform:/plugin/org.eclipse.symphony.examples.worksites.surface/data/CSA-AT-contour-map-black-20cm-per-line.png'''
|-
| ''Height (m)''
| '''120.0'''
|-
| ''Width (m)''
| '''60.0'''
|}

<ol start="4">
	<li> Add a ''Feature Of Interest Map Layer'' named '''myFOI''' to ''myMap'';</li>
	<li> Add a ''Feature Of Interest List'' as a child;</li>
	<li> Add the following ''Features Of Interest'' to that list:</li>
</ol>

{| border="1" cellpadding="2" style="margin-left: 30px;"
! Name
! Position
|-
| Olympus Mons
| '''33.5, 9.5, 2.6'''
|-
| Hill 937
| '''33.0, 43.0, 0.3'''
|}

===== Creating <i>Variables</i> & <i>Contexts</i> =====

<ol>
	<li> In Session ''My First Session'', define a ''Variable'' named '''myRover''' of type ''SymphonySystemMobilePlatform''.</li>
	<li> Create two ''Contexts'':</li>
	<ol type="i">
		<li> Context '''Simulated'''</li>
		<li> Context '''Real'''</li>
	</ol>
	<li> Set '''myRover''' to be implemented using '''MobilePlatformStub''' in the ''Simulated'' ''Context'';</li>
	<li> Set '''myRover''' to be implemented using '''MobilePlatformReal''' in the ''Real'' ''Context'';</li>
	<li> Set the session's ''activeContext'' to '''Simulated''';</li>
	<li> Instantiate the '''Variables''' (by using "Symphony > Reset Instances".)</li>
</ol>

===== Creating <i>Data Products Sets</i> =====

# Set the name of the default ''Data Product Set'' to '''Simulated Data''';
# Create a new ''Data Product Set'' named '''Real Data''';
#* Create an ''Operation Call Results List'' under ''Real Data'';
# Assign '''Simulated Data''' to the ''Simulated'' ''Context'';
# Assign '''Real Data''' to the ''Real'' ''Context'';

==== Issuing Commands ====

The following exercises deal with issuing commands on a Symphony ''System''. By the end of the session, one should be able to:

* invoke operations on simple ''Systems''
* use ''Pose Correctors''
* use ''Operation Call Controller Bindings''

===== Invoking Operations On A Simple <i>System</i> =====

# Under ''Programs'', create an ''Operation Calls'' program called '''myRoverCalls'''
# Create a call named '''Init''' to operation '''init()''' on ''myRover'';
# Create a call named '''Move''' to operation '''cmdLinearVelocity'''() on ''myRover'' with ''Parameter'' '''speed''' set to '''0.25''';
# Create a call named '''Stop''' to operation '''cmdLinearVelocity'''() on ''myRover'' with ''Parameter'' '''speed''' set to '''0.0''';
# Invoke '''Init''' by selecting it, right clicking and choosing "''Symphony > Invoke''"
# Invoke '''Move''' ("''Symphony > Invoke''") - the rover should start moving forward;
# Invoke '''Stop''' ("''Symphony > Invoke''") when you want to stop the rover.

===== Using The <i>Pose Corrector</i> =====

<ol>
	<li> Create an ''Operation Call'' named '''CommandVel''' to '''cmdVelocities'''(''double'', ''double'') on '''myRover''' with the following ''Parameters'':</li>
</ol>

{| border="1" cellpadding="2" style="margin-left: 30px;"
! Parameter
! Value
|-
| ''linearVelocity''
| '''1.5 (m/s)'''
|-
| ''angularVelocity''
| '''5.0 (deg/s)'''
|}

<ol start="2">
	<li> Create an ''Operation Call'' named '''AllStop''' to '''cmdVelocities'''(''double'', ''double'') on '''myRover''' with the following ''Parameters'':</li>
</ol>

{| border="1" cellpadding="2" style="margin-left: 30px;"
! Parameter
! Value
|-
| ''linearVelocity''
| '''0.0 (m/s)'''
|-
| ''angularVelocity''
| '''0.0 (deg/s)'''
|}

<ol start="3">
	<li> In the ''Session Editor'', expand the ''Active Context'' (''Simulated'');</li>
	<li> Expand the ''Variable Implementations'';</li>
	<li> Expand '''myRover''';</li>
	<li> Expand the ''API Adapter'' (''MobilePlatformSymphonySystemApiAdapter'');</li>
	<li> Right-click on the ''Vehicle Pose Corrector'' and select "''Symphony > Enable / Disable Pose Corrector''";</li>
	<li> Invoke '''CommandVel''' to move the rover;</li>
	<li> When ready, invoke '''AllStop''' to stop it.</li>
</ol>

===== Using <i>Operation Call Controller Bindings</i> =====

The following exercises investigate ''Operation Call Controller Bindings''.  By the end of this session, one should be able to:

* Bind a controller to interact with a ''System'' in a variety of ways

====== Binding A Controller To Move The Rover Around ======

# Open the ''Controllers Status View'';
# Under ''Programs'', create a ''Controllers Configuration'' named '''myFirstCtrlConfig'''
# Create an ''Operation Call Controller Binding'' named '''Velocity''' for the '''myRover''' ''Variable'' that binds the '''cmdVelocities'''(''double'', ''double'') operation:
#* Create a ''TimeTrigger'' to get a periodic call at 10 Hz (every 100 ms)
# Create the '''linearVelocity''' ''Parameter'' and map it to a joystick input axis;
<ol>
	<ol type="a">
		<li> Add a ''Centered Linear Input Conditioning'' with the following values:</li>
	</ol>
</ol>

{| border="1" cellpadding="2" style="margin-left: 70px;"
! Parameter
! Value
|-
| ''Dead Band''
| '''0.1'''
|-
| ''Maximum''
| '''-2.0'''
|-
| ''Minimum''
| '''2.0'''
|}

<ol>
	<ol type="a" start="2">
		<li> Create the '''angularVelocity''' ''Parameter'' and map it to a joystick input axis;</li>
		<ul>
			<li> Add a ''Centered Linear Input Conditioning'' with the following values:</li>
		</ul>
	</ol>
</ol>

{| border="1" cellpadding="2" style="margin-left: 110px;"
! Parameter
! Value
|-
| ''Dead Band''
| '''0.1'''
|-
| ''Maximum''
| '''-0.5'''
|-
| ''Minimum''
| '''0.5'''
|}

<ol start="5">
	<li> Activate the '''myFirstCtrlConfig''' and drive your rover around!</li>
</ol>

====== Binding A Controller To Move The Rover Around, With An Enabled Button ======

<ol>
	<li> Create another ''Controllers Configuration'' named '''mySecondCtrlConfig'''.</li>
	<li> Create an ''Operation Call Controller Binding'' named '''Velocity''' for the '''myRover''' ''Variable'' that binds the '''cmdVelocities(''double'', ''double'')''' operation:</li>
	<ul>
		<li> Create a ''State Trigger'' to get a periodic call at 10 Hz (every 100 ms) when a given joystick button is pressed (i.e. dead man's switch)</li>
	</ul>
	<li> Create the '''angularVelocity''' ''Parameter'' and map it to a joystick input axis;</li>
	<ol type="a">
		<li> Add a ''Centered Linear Input Conditioning'' with the following values:</li>
	</ol>
</ol>

{| border="1" cellpadding="2" style="margin-left: 70px;"
! Parameter
! Value
|-
| ''Dead Band''
| '''0.1'''
|-
| ''Maximum''
| '''-2.0'''
|-
| ''Minimum''
| '''2.0'''
|}

<ol>
	<ol type="a" start="2">
		<li> Create the '''linearVelocity''' ''Parameter'' and map it to a joystick input axis;</li>
		<ul>
			<li> Add a ''Centered Linear Input Conditioning'' with the following values:</li>
		</ul>
	</ol>
</ol>


{| border="1" cellpadding="2" style="margin-left: 110px;"
! Parameter
! Value
|-
| ''Dead Band''
| '''0.1'''
|-
| ''Maximum''
| '''-0.5'''
|-
| ''Minimum''
| '''0.5'''
|}

<ol start="4">
	<li> Activate the '''mySecondCtrlConfig''' and drive your rover around. '''''Does it work as expected?'''''</li>
</ol>

==== Defining & Using A Composite <i>System</i> ====

The following exercises illustrated how to specify and use composite ''Systems''.  By the end of this session, one should be able to:

* define an adhoc composite ''System''
* invoke operations on a composite ''System'''s ''Type Members'' as well as on the ''Type Member'''s ''Features''

===== The Target Assembly =====

The desired target assembly for this exercise is:

[[File:../resources/tutorials/composite_system_target_assembly.svg]]

This should yield a composite ''System'' that looks like this:

[[File:../resources/tutorials/composite_system_target_assembly_visualized.png|400x400px]]

===== Defining A Composite <i>System</i> =====

<ol>
	<li> Create a new ''Symphony System'' in ''Local Type'' named '''MyFirstAssembly'''</li>
	<li> Add three (3) ''Type Members'':</li>
	<ol type="i">
		<li> '''rover''' of type ''MobilePlatformSymphonySystem'';</li>
		<li> '''camera''' of type ''PTUCameraSymphonySystem'';</li>
		<li> '''arm''' of type ''RoboticArmSymphonySystem''</li>
	</ol>
	<li> Add a ''Topology Root'' with a ''Transform Node'' child with its ''Node Id'' set to '''myFirstAssemblyRoot'''</li>
	<li> Under '''MyFirstAssembly''', create a ''Connection Points List''</li>
	<li> Under the new ''Connection Points List'', create a ''Connection Point'' named '''ORIGIN''', referring to the '''myFirstAssemblyRoot''' node.</li>
	<li> Under '''MyFirstAssembly''', create an ''Assembly Links List'';</li>
	<li> Create a first ''Assembly Link'' named '''AssemblyToRover''':</li>
	<ol type="i">
		<li> Set its ''Parent Connection Point'' to '''ORIGIN''';</li>
		<li> Set its ''Sub System Type Member'' to '''rover''';</li>
	</ol>
	<li> Create a second ''Assembly Link'' named '''RoverToCamera''':</li>
	<ol type="i">
		<li> Set its ''Parent Type Member'' to '''rover''';</li>
		<li> Set its ''Parent Connection Point'' to '''MOBILE_PLATFORM_SYM_SYS_CONNECT_MAST_CENTRE_PLATE''';</li>
		<li> Set its ''Sub System Type Member'' to '''camera''';</li>
	</ol>
	<li> Create a third ''Assembly Link'' named '''RoverToArm''':</li>
	<ol type="i">
		<li> Set its ''Parent Type Member'' to '''rover''';</li>
		<li> Set its ''Parent Connection Point'' to '''MOBILE_PLATFORM_SYM_SYS_CONNECT_ARM_MOUNT''';</li>
		<li> Set its ''Sub System Type Member'' to '''arm''';</li>
	</ol>
	<li> Set the ''Pose Provider'' of '''MyFirstAssembly''' to '''rover''';</li>
	<li> Create a ''Variable'' named '''myAssembly''' of type ''MyFirstAssembly'';</li>
	<li> In the ''Active Context'', create a new ''Variable Implementation'':</li>
	<ol type="i">
		<li> Assign its ''Variable'' to '''myAssembly''';</li>
		<li> Specify an implementation class for:</li>
		<ul>
			<li> '''rover''' -> '''MobilePlatformSimulated'''</li>
			<li> '''camera''' -> '''PTUCameraSimulated'''</li>
			<li> '''arm''' -> '''RoboticArmSimulated'''</li>
		</ul>
	</ol>	
	<li> Right click on the ''Symphony Environment'' and select "Symphony > Reset Instances".</li>
</ol>

===== Invoking <i>Operations</i> on Composite System <i>Type Members</i> =====

# Create an ''Operation Calls'' program called '''myAssemblyCalls''';
# Create a call named '''Init''' to operation '''init'''() on '''myAssembly:rover'''
# Create a call named '''Move''' to operation '''cmdLinearVelocity'''(''double'') on '''myAssembly:rover''' with ''Parameter'' '''speed''' set to '''0.25''';
# Create a call named '''Stop''' to operation '''cmdLinearVelocity'''(''double'') on '''myAssembly:rover''' with ''Parameter'' '''speed''' set to '''0.0''';
# Invoke '''Init''';
# Invoke '''Move''' - the assembly should start moving forward;
# invoke '''Stop''', when you want to stop your assembly.

===== Invoking <i>Operations</i> on a <i>Feature</i> of Composite System <i>Type Members</i> =====

# Create a call named '''Power On''' to operation '''turnOn'''() on '''myAssembly:rover.powerSystem''';
# Invoke ''Power On''. 

==== Setting Up & Using the <i>Camera View</i> ====

The goal of the following exercises is to understand how the ''Camera View'' operates and learn how to use to it.  By the end of this session, one should be able to:

* configure the ''Camera View''
* add ''Overlays'' to the ''Camera View''

===== Configuring the <i>Camera View</i> =====

# Create a ''Camera Configurations List'' under ''Tools'';
# Create a ''Camera Configuration'' named '''myCameraViewConfig''';
# Set the ''Variable'' and ''Camera'' to refer to the camera of '''myAssembly''' ('''myAssembly:camera''');
# Open the ''Camera View'' and then select '''myCameraViewConfig''';
# Create a call named '''AcquireImage''' to operation '''takeSnapshot'''() on '''myAssembly:camera''';
# Invoke '''acquireImage'''.

===== Adding <i>Overlays</i> =====

<ol>
	<li> Add an ''EMF Feature Overlay'' to display the current pan angle of the camera on the top left corner of the view:</li>
	<ol type="i">
		<li> Create a ''Variable Feature Reference'', set the ''Variable'' to '''myAssembly''';</li>
		<li> Create a ''Type'' referring to '''camera''';</li>
		<li> Create a ''Feature'' chain referring to '''currentPanAngle''';</li>
	</ol>
	<li> Add a ''Gray Scale Filter'' to '''myCameraViewConfig''';</li>
	<li> Create a call named '''MoveToPanTilt''' to operation '''moveToPanTilt'''(''double'', ''double'') on '''myAssembly:camera''';</li>
	<li> Call '''AcquireImage''' on '''camera''' to get the image to update;</li>
	<li> Call '''MoveToPanTilt''' on '''camera''' to change the camera orientation;</li>
	<li> Call '''AcquireImage''' again on '''camera''' to get the image to update.</li>
</ol> 

==== Setting Up & Using The <i>Map View</i> ====

The following exercises demonstrate how the ''Map View'' operates and how it is used.  By the end of this section, one should be able to:

* configure the ''Map View'' to display the ''Environment''
* display ''Variables'' in the ''Map View'' 

===== Displaying The <i>Environment</i> =====

# Create a ''Map View Configuration List'' under ''Tools'';
# Create a ''Map View Configuration'' named '''myMapConfig''';
# Create an ''Image Map Layer Presentation'' referring to '''myContours''';
# Create a ''Feature Of Interest Map Layer Presentation'' referring to '''myFOI''';
# Open the ''Map View'' and select '''myMapConfig'''.

===== Displaying The <i>Variables</i> =====

<ol>
	<li> Create a ''Vehicle Variable Annotation'' referring to '''myRover''';</li>
	<li> Create a ''Variable Trajectory Annotation'':</li>
	<ol type="i">
		<li> Create a ''Default Trajectory Provider'' as its child;</li>
		<li> Assign its ''Variable'' to '''myRover''';</li>
		<li> Close the Map View;</li>
		<li> Open the Map View and select '''myMapConfig'''.</li>
	</ol>
</ol>

----

=== Creating & Symphonyzing A Pan-Tilt Unit (PTU) Camera <i>System</i> ===

The following exercises go step-by-step through the process of creating a ''System'' for a camera mounted on a pan-tilt unit (PTU).  Through the process of creating the final '''''PTUCamera''''' ''System'', one should learn how to:

* Create the Eclipse Modeling Framework (EMF) Model for the ''System''
* Create the Symphony plug-in and required specialized subclasses
* Create the appropriate ''Symphony System Model'' and register it with Symphony 
* Test the ''System'' throughout the development process 

==== An Overview Of The Desired <i>System</i> ====

The class structure for the ''PTUCamera'''s ''System'' should be as follows:

[[File:../resources/tutorials/ptu_camera_class_hierarchy.svg]]

==== 1. Creating The <i>PTUCamera</i>'s EMF Meta-Model ====

The following exercises go through the process of creating the required EMF meta-model for the new ''PTUCamera'' System.  By the end of this section, one should be able to:

* create the EMF meta-model for a given ''System'';
* implement / override the required methods in the ''System'''s generated code;
* test the fully implemented ''System''.

===== i. Creating The <i>PTUCamera</i>'s EMF Model =====

<ol>
	<li> Create a new ''Xcore Project'' named '''<org_prefix>.ptu''', where ''<org_prefix>'' is replaced by an appropriate prefix for your organization.</li>
	<li> In the '''/model''' folder, create an Xcore model named '''ptu.xcore'''</li>
	<li> Copy the following to the start of the empty Xcore model, replacing ''<org_prefix>'' where required:</li>
</ol>

<code>
     @GenModel(prefix="PTUCamera",
       	      modelName="PTUCamera",
    	      childCreationExtenders="true",
               extensibleProviderFactory="true",
               multipleEditorPages="false",
               operationReflection="true",
               suppressGenModelAnnotations="false")
     @GenModel(modelDirectory="/<org_prefix>.ptu/src-generated")
     @GenModel(editDirectory="/<org_prefix>.ptu.edit/src-generated")

     package <org_prefix>.ptu
</code>

<ol start="4">
	<li> Create the class hierarchy shown before (classes in blue);</li>
	<li> Save the '''ptu.xcore''' file.  This will trigger the code generation in both the '''<org_prefix>.ptu''' and '''<org_prefix>.ptu.edit''' plugins.</li>
</ol>

===== ii. Implementing the Required Methods =====

<ol>
	<li> Implement the following methods in ''<org_prefix>.ptu.impl.CameraImpl'':</li>
</ol>

{| border="1" cellpadding="2" style="margin-left: 30px;"
! Method
! Description
|-
| ''RectangularFieldOfView()'' '''getFov'''()
| Getter method for the ''fov'' attribute of the camera.  See the code provided.
|-
| ''boolean'' '''commandZoom'''(''double'' zoom)
| Configures the current zoom; this needs to update the FOV as well!  See the code provided.
|-
| ''double'' '''getMinimumZoom'''()
| Returns the minimum zoom factor.  Return '''1.0''';
|-
| ''double'' '''getMaximumZoom'''()
| Returns the maximum zoom factor.  Return '''10.0''';
|-
| ''RectangularFrustrumFieldOfView'' '''getFieldOfView'''()
| Method declared by ''AbstractCamera''.  Return '''getFov()''';
|}

<ol start="2">
	<li> Implement the following methods in ''<org_prefix>.ptu.impl.CameraSimulatedImpl'':</li>
</ol>

{| border="1" cellpadding="2" style="margin-left: 30px;"
! Method
! Description
|-
| ''boolean'' '''initialize'''()
| Initialize the camera.  Just return '''true''';
|-
| ''ImageSnapshot'' '''takeSnapshot'''()
| Takes and returns an ''ImageSnapshot''. See the code provided.
|}

<ol start="3">
	<li> Implement the following methods in ''<org_prefix>.ptu.impl.PTUCameraSimulatedImpl'':</li>
</ol>

{| border="1" cellpadding="2" style="margin-left: 30px;"
! Method
! Description
|-
| ''double'' '''getMaximumPanAngle'''()
| Returns the maximum pan angle ('''in radians''').  Just return '''170.0 degrees'''.
|-
| ''double'' '''getMinimumPanAngle'''()
| Returns the minimum pan angle ('''in radians''').  Just return '''-170.0 degrees'''.
|-
| ''double'' '''getMaximumTiltAngle'''()
| Returns the maximum tilt angle ('''in radians''').  Just return '''90.0 degrees'''.
|-
| ''double'' '''getMinimumTiltAngle'''()
| Returns the minimum tilt angle ('''in radians''').  Just return '''-45.0 degrees'''.
|-
| ''boolean'' '''moveToPan'''(''double'' panAngle)
| Checks the commanded pan angle, which is in '''radians'''.  If it's within range, update '''currentPan''' to the commanded value and return true; otherwise, return false.
|-
| ''boolean'' '''moveToTilt'''(''double'' tiltAngle)
| Checks the commanded tilt angle, which is in '''radians'''.  If it's within range, update '''currentTilt''' to the commanded value and return true; otherwise, return false. 
|-
| ''boolean'' '''moveToPanTilt'''(''double'' panAngle, ''double'' tiltAngle)
| Checks the commanded pan and tilt angles, both of which are in '''radians'''.  If they are within range, update both '''currentPan''' and '''currentTilt''' to the commanded values and return true; otherwise, return false.
|-
| ''boolean'' '''moveByPan'''(''double'' panAngleDelta)
| Checks the sum of '''currentPan''' and the commanded pan angle offset (given in '''radians''').  If the resulting pan angle is in range, update '''currentPan''' to the resultant value and return true; otherwise, return false. 
|-
| ''boolean'' '''moveByTilt'''(''double'' tiltAngleDelta)
| Checks the sum of '''currentTilt'''and the commanded tilt angle offset (given in '''radians''').  If the resulting tilt angle is in range, update '''currentTilt''' to the resultant value and return true; otherwise, return false. 
|-
| ''boolean'' '''moveByPanTilt'''(''double'' panAngleDelta, ''double'' tiltAngleDelta)
| Checks the sum of '''currentPan''' and the commanded pan angle offset (given in '''radians''') as well as the sum of '''currentTilt''' and the commanded tilt angle offset (given in '''radians''').  If both resulting angles are in range, update both '''currentPan''' and '''currentTilt''' to the resultant values and return true; otherwise, return false.
|-
| ''boolean'' '''stopMotion'''()
| Stops all motion.  Just return true.
|}

===== iii. Testing the <i>System</i> =====

# Create a new ''Eclipse Application'' under ''Run Configuration''. Name it '''TEST''';
# Click ''Run'' to launch another instance of Eclipse with your plugins;
# In the ''Project Explorer View'', create a new Symphony Project (by clicking on ''New > Other... > Symphony > New Symphony Project'').  Name it '''my_tests''';
# Create a new Symphony Session named '''MySession.sym''' in the newly create project.
# In the ''Types'', under ''Local'', create a ''Type'' named '''PTUCamera''';
# Set the type's ''Interface Class'' to ''<org_prefix>.ptu.PTUCamera'';
# Under ''Variables'', create a ''Variable'' named '''ptuCamera''' and specify its type as '''PTUCamera''';
# In the '''Default''' ''Context'', add a ''Variable Implementation'' that maps variable '''ptuCamera''' to a ''<org_prefix>.ptu.SimulatedPTUCamera'' implementation;
# Select the ''Symphony Environment'' and right-click, selecting ''Symphony > Reset Instances'' to initialize instances;
# Under ''Programs'', create an ''Operation Call List'' named '''ptuCmd''';
# Under ''ptuCmd'', create an ''Operation Call'' named '''Init''' referencing '''ptuCamera.initialize'''();
# Invoke the '''Init''' ''Operation Call'' and verify that the command has been executed;
# Under ''ptuCmd'', create an ''Operation Call'' named '''MoveTo''' referencing '''ptuCamera.moveToPanTilt'''(''double'', ''double''), with a '''pan''' ''Parameter'' of '''45.0''' degrees and a '''tilt''' ''Parameter'' of '''-30.0''' degrees; 
# Invoke the '''MoveTo''' ''Operation Call'' and verify that the command has been executed;
# Under ''ptuCmd'', create an ''Operation Call'' named '''Zoom''' referencing '''ptuCamera.commandZoom'''(''double''), with a '''zoom''' ''Parameter'' of '''2.0''';
# Invoke the '''Zoom''' ''Operation Call'' and verify that the command has been executed;
# Under ''ptuCmd'', create an ''Operation Call'' named '''SnapShot''' referencing '''ptuCamera.takeSnapshot'''()
# Invoke the '''SnapShot''' ''Operation Call'' and verify that the command has been executed.

==== 2. Creating the <i>PTUCamera</i>'s Symphony Plug-in ====

The following exercises focus on creating the Symphony plugin for the new ''PTUCamera'' ''System''.  By the end of this section, one should be able to:

* Create Symphony plug-in projects
* Develop Symphony EMF meta-model for a ''System''
* Specialize both ''SymphonyInitializationData'' and ''SymphonySystemApiAdapter'' classes for a given ''System''

===== i. Creating The <i>PTUCamera</i>'s Plug-in Project =====

<ol>
	<li> Create a new ''Xcore Project'' named '''<org_prefix>.ptu.symphony''';</li>
	<li> Open the '''MANIFEST.MF'''.  Go to the ''Dependencies'' tab;</li>
	<li> In the ''Required Plug-ins'' section:</li>
	<ol type="i">
		<li> Add your ''<org_prefix>.ptu'' plugin to the dependencies;</li>
		<li> Add the ''org.eclipse.symphony.core'' plugin to the dependencies;</li>
	</ol>
	<li> Save the '''MANIFEST.MF'''</li>
</ol>

===== ii. Developing the <i>PTUCamera</i>'s Symphony Xcore (.xcore) model =====

<ol>
	<li> Rename the '''/src-gen''' folder to '''/src-generated''';</li>
	<li> In the '''/model''' folder, copy over the provided file '''ptu_symphony.xcore''';</li>
	<li> Replace the <org_prefix> in the model with the appropriate name:</li>
	<ol type="i">
		<li> Ensure that you change the '''modelDirectory''' @GenModel directive to <org_prefix>.ptu.symphony'''/src-generated'''</li>
		<li> Ensure that you change the '''editDirectory''' @GenModel directive to <org_prefix>.ptu.symphony.edit'''/src-generated'''</li>
	</ol>
</ol>

===== iii. Specializing <i>SymphonyInitializationData</i> for the <i>PTUCamera</i> =====

<ol>
	<li> Open the '''ptu_symphony.xcore''' model;</li>
	<li> Define a new class named '''''PTUCameraSymphonyInitializationData''''' that extends ''SymphonyInitializationData'';</li>
	<li> Add the required attributes:</li>
	<ol type="i">
		<li> ''double'' '''panAngle''';</li>
		<li> ''double'' '''tiltAngle''';</li>
		<li> ''double'' '''zoomFactor''' (with a default value of '''1.0''')</li>
	</ol>
	<li> Save the '''ptu_symphony.xcore''' model.</li>
</ol>

===== iv. Specializing <i>SymphonySystemApiAdapter</i> for the <i>PTUCamera</i> =====

# Open the '''ptu_symphony.xcore''' model;
# Define a new class named '''''PTUCameraSymphonySystemApiAdapter''''' that extends ''SymphonySystemApiAdapter''';
# Save the '''ptu_symphony.xcore''' model;
# Implement the following methods in <org_prefix>.ptu.symphony.impl.'''''PTUCameraSymphonySystemApiAdapterImpl''''' as specified below:

 	/**
 	 * Create a new instance of ''PTUCameraSymphonyInitializationData'',
 	 * which is the relevant subclass of ''SymphonyInitializationData''
 	 * for the ''PTUCamera'' ''System''.
 	 * 
 	 * @return The newly created ''PTUCameraSymphonyInitializationData'' object
 	 * @generated_NOT
 	 */
 	@Override
 	public ''AbstractInitializationData'' createInitializationData()
 	{
 		// Create and return a ''PTUCameraSymphonyInitializationData'' 
 		return PTUCameraFactory.createPTUCameraSymphonyInitializationData();
 	}
 
 	/**
 	 * Sets the attributes of the given ''SymphonyInitializationData'' object
 	 * to the corresponding values of the ''PTUCamera'' ''System''' instance's
 	 * state.  In this case, it simply gets the values of '''pan''', '''tilt'''
 	 * and '''zoom''' from the ''System'' instance and stores them in the provided
 	 * ''SymphonyInitializationData'' object, given that it has the correct type.
 	 * 
 	 * @param initData The initialization data object that is supposed to collect the state of the ''System''
 	 * @generated_NOT
 	 */
 	@Override
 	public void collect(''AbstractInitializationData'' initData)
 	{
 		// Call the superclass' version of the method 
 		super.collect(initData);
 		
 		// If the initialization data object has the correct type
 		if (initData instanceof ''PTUCameraSymphonyInitializationData'')
 		{
 			// Cast down
 			''PTUCameraSymphonyInitializationData'' ptuCameraInitData = (''PTUCameraSymphonyInitializationData'') initData;
 			''PTUCamera'' ptuCamera = (''PTUCamera'') this.getInstance();
 		
 			// Store the ''System'' instance's state in the initialization data object
 			ptuCameraInitData.setPanAngle(ptuCamera.getPanAngle());
 			ptuCameraInitData.setTiltAngle(ptuCamera.getTiltAngle());
 			ptuCameraInitData.setZoomFactor(ptuCamera.getCurrentZoom());
 		}
 	}
 
 	/**
 	 * Applies the values in the provided ''SymphonyInitializationData'' to this
 	 * ''PTUCamera'' ''System'' instance.  In this case, it will call the appropriate
 	 * methods to set the instance's state correctly.
 	 *
 	 * @param initData The initialization data object that is supposed to apply its state to the given ''System'' instance.
 	 * @generated_NOT
 	 */
 	@Override
 	public void apply(''AbstractInitializationData'' initData)
 	{
 		// Call the superclass' version of this method
 		super.apply(initData);
 		
 		// If the initialization data object has the correct type
 		if (initData instanceof ''PTUCameraSymphonyInitializationData'')
 		{
 			// Cast down
 			''PTUCameraSymphonyInitializationData'' ptuCameraInitData = (''PTUCameraSymphonyInitializationData'') initData;
 			''PTUCamera'' ptuCamera = (''PTUCamera'') this.getInstance();
 		
 			// Apply the values
 			ptuCamera.commandZoom(ptuCameraInitData.getZoomFactor());
 			ptuCamera.moveToPanTilt(ptuCameraInitData.getPanAngle(),
 									   ptuCameraInitData.getTiltAngle());
 		}
 	}
   
 	/**
 	 * Return a 4x4 matrix, whose components represent the transformation
 	 * (e.g. rotations, translations, etc.) from where the given operation
 	 * took place to the camera's root topology node; for example, for the
 	 * operation ''takeSnapshot''(), this describes the transformation from
  	 * the camera's lens to its base (e.g. root). If no transformation
 	 * occurred, then the identity matrix should be returned; note that this,
 	 * in fact, is what is returned by the superclass' version of this method.
 	 * 
 	 * @param operationCall The operation which took place
 	 * @return The transformation from where the operation took place to the PTU camera's root
 	 * @generated_NOT
 	 */
 	@Override
 	public ''Matrix4x4'' createResultMatrix(''OperationCall'' operationCall) 
 	{
 		// If the takeSnapshot() method was called
 		if (operationCall.getEOperation().getOperationID() == PTUCameraPackage.CAMERA___TAKE_SNAPSHOT)
 		{
 			// Extract the camera lens and root nodes
 			''Node'' tip = TopologyFacade.INSTANCE.findNodesByID("PTU_CAMERA_FOV",
 			                                                 getSymphonySystem().getTopologyRoot().getOriginNode()).get(0);
 			''Node'' root = TopologyFacade.INSTANCE.findNodesByID("PTU_CAMERA_ROOT",
 			                                                  getSymphonySystem().getTopologyRoot().getOriginNode()).get(0);
			
 			// Determine the series of transformations that have taken place
 			''Matrix4d'' matrix4d = TopologyFacade.INSTANCE.expressInFrame(tip,	root);
			
 			// Create a 4x4 Matrix with the transformation and return it
 			return MathFacade.INSTANCE.createMatrix4x4(matrix4d);
 		}
 		// Otherwise, any other operation was called
 		else
 		{
 			// Just return the identity matrix
 			return super.createResultMatrix(operationCall);
 		}
 	}

==== 3. Creating the <i>PTUCamera</i>'s Complete <i>Symphony System</i> Model ====

The following exercises highlight how to create the ''PTUCamera'' System's complete ''Symphony System'' model.  By the end of this section, one should be able to:
 
* Create a ''Symphony System'' model (.ss file)
* Specify the topology for a new ''Symphony System'' model
* Create the bindings for a new ''Symphony System'' model
* Register the new ''Symphony System'' model with Symphony 

===== i.Creating the <i>PTUCamera</i>'s <i>Symphony System</i> Model (.ss file) =====

# Launch the ''Run Configuration'' used for testing ''PTUCamera'' in the previous exercises;
# In the ''Project Explorer'', right click and then select "''Import...''";
# In the ''Import'' pop-up, select "''General -> Existing Projects into Workspace''", then click "''Next >''";
# Select your workspace root directory; the ''Projects'' list will get populated with your plugins. ''De-select'' all of them, except '''<org_prefix>.ptu.symphony''';
# Click ''Finish''.  You now have a reference to your Symphony plugin in your new Eclipse instance;
# Create a Symphony System Model named '''MyPTUCameraSymphonySystem.ss''' in the '''/model''' folder of your '''<org_prefix>.ptu.symphony''' plugin (use the ''New Symphony System'' wizard plugin);
# Set the name of the Symphony System Model to '''MyPTUCameraSymphonySystem''';
# Set the ''Interface Class'' to '''<org_prefix>.ptu.PTUCamera''';
# Set the ''Type Api Adapter Class'' to '''<org_prefix>.ptu.symphony.PTUCameraSymphonySystemApiAdapter''';
# Save the model (*.ss) file.

===== ii. Specifying the Topology for the <i>PTUCamera</i>'s <i>Symphony System</i> Model=====

The following exercises show how to specify the topology for the ''PTUCamera'''s ''Symphony System'' model.  By the end of this section, one should be able to: 

* Create any required subdirectories (and populate them)
* Generate a topology to reflect a given target hierarchy
 
====== Target Topology Hierarchy ======

The desired final topology for ''MyPTUCameraSymphonySystem'' should be as follows:

[[File:../resources/tutorials/ptu_camera_topology.svg]]

Note:
* Create the nodes and set their ID / description right away; this makes it much easier to both understand and navigate the topology.
* URLs in ''URLNodes'' should have the following format: ''platform:/plugin/'''''<org_prefix>.ptu.symphony/cadmodels'''''/filename.ext'' 

====== Target Transformations ======

The desired final transformation for the components of ''MyPTUCameraSymphonySystem'' should be as follows:

[[File:../resources/tutorials/ptu_camera_transforms.svg]]

Recall that the ''RectangularFrustrumFieldOfView'' component of the ''MyPTUCamera'' ''System''   has following properties:

[[File:../resources/tutorials/rectangular_frustrum_fov.svg]]

Once all of the topology in '''MyPTUCameraSymphonySystem.ss''' has been fully populated, the result should look like:

[[File:../resources/tutorials/ptu_camera_transforms_result.png]]

====== Creating the CAD folder ======

# In your '''<org_prefix>.ptu.symphony''' plugin, create a folder '''/cadmodels'''.  This folder will hold the CAD files containing the geometry of your ''System'';
# Copy the CAD files provided to the '''/cadmodels''' folder
# Open the '''MANIFEST.MF''' for your '''<org_prefix>.ptu.symphony''' plugin;
# Go to the ''Build'' tab;
# In the ''Binary Build'' section, select the '''/cadmodels''' folder; this will ensure that it will be included in the binary plugin when installed.
# Save the '''MANIFEST.MF'''

====== Populating the topology ======

# Launch the ''Run Configuration'' used for testing the ''PTUCamera'' in the previous exercises;
# Open your '''PTUCameraSymphonySystem.ss''' file with the editor;
# Open the ''Symphony System 3D Viewer'', then select the ''Symphony System'' in the editor;
# Under ''Topology Root'', create the topology for the ''PTUCamera'', replicating the structure specified in '''Target Topology Hierarchy''' above;
# For the relevant transformations in the new hierarchy, update their position and orientation to reflect those specified in the '''Target Transformations''' section above;
# Save the file.

===== iii. Making the Camera's Bindings =====

====== Defining the <i>Feature Nodes</i> ======

<ol>
	<li> Open your '''PTUCameraSymphonySystem.ss''' file with the editor</li> 
	<li> Under "''Binding Sets -> Feature Roots List''", create a new ''Tree Root Node'', select it and set its ''Source Class'' to '''<org_prefix>.ptu.PTUCamera''';</li>
	<li> Under the new ''Tree Root Node'', create three new ''Tree Feature Nodes'':</li>
	<ol type="i">
		<li> Set the ''Structural Feature'' for the first to '''currentPanAngle''';</li>
		<li> Set the ''Structural Feature'' for the second to '''currentTiltAngle''';</li>
		<li> Set the ''Structural Feature'' for the third to '''fov''';</li>
	</ol>
	<li> Save the ''Symphony System Model'' (*.ss) file;</li>
</ol>

====== Making the Bindings themselves ======

<ol>
	<li> Open your '''PTUCameraSymphonySystem.ss''' file with the editor</li>
	<li> Under "''Binding Sets-> Bindings List''", create the following ''Rotation Bindings'':</li>
</ol>

{| border="1" cellpadding="2" style="margin-left: 30px; text-align:center;"
! Name
! Feature Node
! Rotation Units
! Rotation Node
! Rotation Axis
|-
| Pan Angle
| ''currentPanAngle''
| ''RADIANS''
| ''PTU_CAMERA_PAN_JOINT''
| ''Z_AXIS''
|- 
| Tilt Angle
| ''currentTiltAngle''
| ''RADIANS''
| ''PTU_CAMERA_TILT_JOINT''
| ''MINUS_Y_AXIS''
|}

<ol start="3">
	<li> Similarly, create the following ''Rectangular Frustrum Field Of View Binding'':</li>
</ol>

{| border="1" cellpadding="2" style="margin-left: 30px; text-align:center;"
! Name
! Feature Node
! Field Of View (FOV) Node
|-
| FOV
| ''fov''
| ''PTU_CAMERA_FOV''
|}

<ol start="4">
	<li> Save the .ss file</li>
</ol>

===== iv. Registering the Camera's <i>Symphony System Model</i> =====

# Open the '''MANIFEST.MF''' of your '''<org_prefix>.ptu.symphony''' plugin;
# In the ''Extensions'' tab, click ''Add...'';
# Ensure the ''Show only extension points from the required plug-ins'' is '''NOT''' selected;
# Select the '''org.eclipse.symphony.core.invocator.typeContributor''';
# Click ''Finish'';
# Select the newly added extension and then click on ''Browse'' for the '''URI''' field;
# Browse to your Symphony System Model ('''MyPTUCameraSymphonySystem.ss''') file and then click ''OK'';
# Save the '''MANIFEST.MF'''

==== 4. Testing the completed PTU Camera in Symphony ====

# Launch the ''Run Configuration'' used for testing the ''PTUCamera'' in the previous exercises;
# Open '''MySession.sym''';
# Expand ''Session -> Symphony Environment -> Types -> Registered'': the '''MyPTUCameraSymphonySystem''' should be present;
# Open the ''Symphony 3D Viewer'', then select the ''Symphony Environment''; this will make the ''3D Viewer'' display your environment;
# Under ''Symphony Environment'', create a new ''Worksites'';
# Under ''Worksites'', create a new ''Earth Surface Worksite'';
# Set the '''Active Worksite''' of the ''Symphony Environment'' to the new ''Earth Surface Worksite'';
# Select the '''ptuCamera''' ''Variable'' and set its ''Variable Type'' to ''MyPTUCameraSymphonySystem'';
# Reset Instances: Your ''PTUCamera'' should appear in the 3D Viewer;
# Invoke the ''Operation Calls'' defined in the previous exercises and confirm that the ''System'' responds correctly;
# Done!

