= Table Of Contents =
__TOC__

= Examples =

* Simple examples of simulated ''Systems'';
* Examples include articulated and composite ''Systems'' and the use of the ''Environment'' for simulation;
* As recommended, the ''System'''s EMF models are separate and distinct from their Symphony (System) plugins;
* Shows various aspects of ''Symphonyzation''

* The following examples are currently available in Symphony:

{| border="1" cellpadding="2"
! Symphony System
! Description
! Plugin
|-
| '''''PTUDishAntennaSymphonySystem'''''
| A simulated antenna dish mount on a pan-tilt unit.  Antenna is made to track the Sun based on the worksite sky.
| ''org.eclipse.symphony.examples.antenna''
|-
| '''''CameraSymphonySystem'''''
| A simulated camera.
| rowspan="2" | ''org.eclipse.symphony.examples.camera''
|-
| '''''PTUCameraSymphonySystem'''''
| A simulated camera mounted on a pan-tilt unit.
|-
| '''''LanderSymphonySystem'''''
| A simulated lander.
| ''org.eclipse.symphony.examples.lander''
|-
| '''''LidarSymphonySystem'''''
| A simulated raster scan LIDAR.
| ''org.eclipse.symphony.examples.lidar''
|-
| '''''MobilePlatformSymphonySystem'''''
| A simulated four-wheeled, skid-steered mobile platform.
| ''org.eclipse.symphony.examples.mobile_platform''
|-
| '''''RoboticArmSymphonySystem'''''
| A simulated robotic arm with four rotatable joints
| ''org.eclipse.symphony.examples.robotic_arm''
|-
| '''''RoverSymphonySystem'''''
| A simulated rover, which is a complex System, composed of a Mobile Platform, Robotic Arm and two Camera sub-Systems.
| ''org.eclipse.symphony.examples.rover''
|}

== PTU Dish Antenna ==

TODO!

== Camera ==

TODO!

== PTU Camera ==

TODO!

== Lander ==

TODO!

== Lidar ==

TODO!

== Mobile Platform ==

TODO!

== Robotic Arm ==

TODO!

== Rover (Complex System) ==

TODO!

----

= Tutorials =

== I'm in a hurry! I want to operate a rover!!! ==
TODO!

== Getting Started Exercises ==

=== Setting Up A <i>Symphony Environment</i> ===

==== Creating A <i>Symphony Session</i> ====

# Create a new ''Symphony Project'' named '''SymphonyTraining''';
# Create a new ''Symphony Session'' named '''MyFirstSession.'''

==== Creating A <i>Worksite</i> ====

# Under ''Symphony Environment'', create a new ''Worksites'';
# Under ''Worksites'', create a new ''Earth Surface Worksite'' named '''TrainingSite''';
# Delete the elements under ''Maps List'';
# Sets the ''X Axis Azimth'' to '''179.4 degrees''';
# Select the ''Symphony Environment'' and set its ''Active Worksite'' to '''TrainingSite''';
# Open the ''Symphony 3D Viewer'' and select the ''Symphony Environment''; 

==== Creating <i>Map Layers</i> ====

# Add a map named '''myMap''' to the ''TrainingSite's Map List'';
# Add a ''Cartesian Triangular Mesh URL Map Layer'' named '''myDEM''' to ''myMap'' with the following parameters:

{| border="1" cellpadding="2"
! Parameter
! Value
|-
| Url
| platform:/plugin/org.eclipse.symphony.examples.worksites.surface/data/CSAAnalogTerrainDEM100cm.tri
|}

# Add a ''URL Image Map Layer'' named '''myContours''' to ''myMap'' with the following parameters:

{| border="1" cellpadding="2"
! Parameter
! Value
|-
| Url
| platform:/plugin/org.eclipse.symphony.examples.worksites.surface/data/CSA-AT-contour-map-black-20cm-per-line.png
|-
| Height (m)
| 120.0
|-
| Width (m)
| 60.0
|}

# Add a ''Feature Of Interest Map Layer'' named '''myFOI''' to ''myMap'';
# Add a ''Feature Of Interest List'' as a child;
# Add the following ''Features Of Interest'' to that list:

{| border="1" cellpadding="2"
! Name
! Position
|-
| Olympus Mons
| 33.5, 9.5, 2.6
|-
| Hill 937
| 33.0, 43.0, 0.3
|}

==== Creating <i>Variables</i> & <i>Contexts</i> ====

# In Session ''My First Session'', define a ''Variable'' named '''myRover''' of type ''SymphonySystemMobilePlatform''.
# Create two ''Contexts'':
## Context '''Simulated'''
## Context '''Real'''
# Set ''myRover'' to be implemented using '''MobilePlatformStub''' in the ''Simulated'' ''Context'';
# Set ''myRover'' to be implemented using '''MobilePlatformReal''' in the ''Real'' ''Context'';
# Set the session's ''activeContext'' to '''Simulated''';
# Instantiate the '''Variables''' (by using "Symphony > Reset Instances".)

==== Creating <i>Data Products Sets</i> ====

# Set the name of the default ''Data Product Set'' to '''Simulated Data''';
# Create a new ''Data Product Set'' named '''Real Data''';
#* Create an ''Operation Call Results List'' under ''Real Data'';
# Assign '''Simulated Data''' to the ''Simulated'' ''Context'';
# Assign '''Real Data''' to the ''Real'' ''Context'';

=== Issuing Commands ===

==== Invoking Operations On A Simple System ====

# Under ''Programs'', create an ''Operation Calls'' program called '''myRoverCalls'''
# Create a call named '''Init''' to operation '''init()''' on ''myRover'';
# Create a call named '''Move''' to operation '''cmdLinearVelocity()''' on ''myRover'' with ''Parameter'' '''speed''' set to '''0.25''';
# Create a call named '''Stop''' to operation '''cmdLinearVelocity()''' on ''myRover'' with ''Parameter'' '''speed''' set to '''0.0''';
# Invoke Init by selecting "Symphony > Invoke"
# Invoke Move ("Symphony > Invoke") - the rover should start moving forward;
# Invoke Stop ("Symphony > Invoke") when you want to stop the rover.

==== Using The <i>Pose Corrector</i> ====

# Create an ''Operation Call'' named '''CommandVel''' to '''cmdVelocities(...)''' on ''myRover'' with the following ''Parameters'':

{| border="1" cellpadding="2"
! Parameter
! Value
|-
| linearVelocity
| 1.5 (m/s)
|-
| angularVelocity
| 5.0 (deg/s)
|}

# Create an ''Operation Call'' named '''AllStop''' to '''cmdVelocities(...)''' on ''myRover'' with the following ''Parameters'':

{| border="1" cellpadding="2"
! Parameter
! Value
|-
| linearVelocity
| 0.0 (m/s)
|-
| angularVelocity
| 0.0 (deg/s)
|}

# In the ''Session Editor'', expand the ''Active Context'' (''Simulated'');
# Expand the ''Variable Implementations'';
# Expand ''myRover'';
# Expand the ''API Adapter'' (''Mobile Platform Symphony System Api Adapter'');
# Right-click on the ''Vehicle Pose Corrector'' and select "Symphony > Enable/Disable Pose Corrector";
# Invoke ''CommandVel'' to move the rover
# When ready, invoke ''AllStop'' to stop it.

==== Using Operation Call Controller Bindings ====

===== Binding A Controller To Move The Rover Around =====

# Open the ''Controllers Status View'';
# Under ''Programs'', create a ''Controllers Configuration'' named '''myFirstCtrlConfig''
# Create an ''Operation Call Controller Binding'' named '''Velocity''' for the ''myRover'' ''Variable'' that binds the '''cmdVelocities(...)''' operation:
#* Create a ''TimeTrigger'' to get a periodic call at 10 Hz (every 100 ms)
# Map the ''linearVelocity'' parameter to a joystick input axis;
## Add a ''Centered Linear Input Conditioning with the following values:

{| border="1" cellpadding="2"
! Parameter
! Value
|-
| Dead Band
| 0.1
|-
| Maximum
| -2.0
|-
| Minimum
| 2.0
|}

## Map the ''angularVelocity'' ''Parameter'' to a joystick inpit axis;
##* Add a ''Centered Linear Input Conditioning'' with the following values:

{| border="1" cellpadding="2"
! Parameter
! Value
|-
| Dead Band
| 0.1
|-
| Maximum
| -0.5
|-
| Minimum
| 0.5
|}

# Activate the ''myFirstCtrlConfig'' and drive your rover around!

===== Binding A Controller To Move The Rover Around, With An Enabled Button =====

# Create another ''Controllers Configuration'' named '''mySecondCtrlConfig'''.
# Create an ''Operation Call Controller Binding'' named '''Velocity''' for the ''myRover'' ''Variable'' that binds the '''cmdVelocities(...)''' operation:
#* Create a ''State Trigger'' to get a periodic call at 10 Hz (every 100 ms) when a given joystick button is pressed (i.e. dead man's switch)
# Map the ''angularVelocity'' parameter to a joystick input axis;
## Add a ''Centered Linear Input Conditioning'' with the following values:

{| border="1" cellpadding="2"
! Parameter
! Value
|-
| Dead Band
| 0.1
|-
| Maximum
| -2.0
|-
| Minimum
| 2.0
|}

## Map the ''linearVelocity'' parameter to a joystick input axis;
##* Add a ''Centered Linear Input Conditioning'' with the following values:

{| border="1" cellpadding="2"
! Parameter
! Value
|-
| Dead Band
| 0.1
|-
| Maximum
| -0.5
|-
| Minimum
| 0.5
|}

# Activate the ''mySecondCtrlConfig'' and drive your rover around. '''''Does it work as expected?'''''

=== Defining & Using Composite <i>Types</i> ===

==== The Target Assembly ====
TODO!

==== Defining A Composite <i>System</i> ====

# Create a new ''Symphony System'' in ''Local Type'' named '''MyFirstAssembly'''
# Add three (3) ''Type Members'':
## '''rover''' of type ''SymphonySystemMobilePlatform'';
## '''camera''' of type ''SymphonySystemPTUCamera'';
## '''arm''' of type ''SymphonySystemRoboticArm''
# Add a ''Topology Root'' with a ''Transform Node'' child with its ''Node Id'' set to '''myFirstAssemblyRoot'''
# Under ''MyFirstAssembly'', create a ''Connection Points List''
# Under the new ''Connection Points List'', create a ''Connection Point'' named '''origin''', referring to the ''myFirstAssemblyRoot'' node.
# Under ''MyFirstAssembly'', create an ''Assembly Links List'';
# Create a first ''Assembly Link'' named '''assemblyToRover''':
## Set its ''Parent Connection Point'' to '''origin''';
## Set its ''Sub System Type Member'' to '''rover''';
# Create a second ''Assembly Link'' named ''roverToCamera'':
## Set its ''Parent Type Member'' to '''rover''';
## Set its ''Parent Connection Point'' to '''MOBILE_PLATFORM_SYM_SYS_CONNECT_MAST_CENTRE_PLATE''';
## Set its ''Sub System Type Member'' to '''camera''';
# Create a third ''Assembly Link'' named ''roverToArm'':
## Set its ''Parent Type Member'' to '''rover''';
## Set its ''Parent Connection Point'' to '''MOBILE_PLATFORM_SYM_SYS_CONNECT_ARM_MOUNT''';
## Set its ''Sub System Type Member'' to '''arm''';
# Set the ''Pose Provider'' of ''myFirstAssembly'' to '''rover''';
# Create a ''Variable'' named '''myAssembly''' of type ''MyFirstAssembly'';
# In the ''Active Context'', create a new ''Variable Implementation'':
## Assign its ''Variable'' to '''myAssembly''';
## Specify an implementation class for:
### ''rover'' -> '''MobilePlatformStub'''
### ''camera'' -> '''PTUCameraSimulated'''
### ''arm'' -> '''RoboticArmSimulated'''
# Reset Instances

==== Invoking Operation On Composite System <i>Type Members</i> ====

# Create an ''Operation Calls'' program called '''myAssemblyCalls''';
# Create a call named '''Init''' to operation ''init()'' on ''myAssembly:rover''
# Create a call named '''Move''' to operation ''cmdLinearVelocity(...)'' on ''myAssembly:rover'' with ''Parameter'' '''speed''' set to '''0.25''';
# Create a call named '''Stop''' to operation ''cmdLinearVelocity(...)'' on ''myAssembly:rover'' with ''Parameter'' '''speed''' set to '''0.0''';
# Invoke ''Init'';
# Invoke ''Move'' - the assembly should start moving forward;
# invoke ''Stop'', when you want to stop your assembly.

==== Invoking Operation On A Feature Of Composite System <i>Type Members</i> ====

# Create a call named '''Power On''' to operation ''turnOn()'' on ''myAssembly:rover.powerSystem'';
# Invoke ''Power On''. 

=== Setting Up & Using The <i>Camera View</i> ===

==== Configuring A <i>Camera View</i> ====

# Create a ''Camera Configurations List'' under ''Tools'';
# Create a ''Camera Configuration'' named '''myCameraViewConfig''';
# Set the ''Variable'' and ''Camera'' to refer to the camera of ''myAssembly'' ('''myAssembly:camera''');
# Open the ''Camera View'' and then select ''myCameraViewConfig'';
# Create a call named '''acquireImage''' to operation ''takeSnapshot()'' on ''myAssembly:camera'';
# Invoke ''acquireImage''.

==== Adding Overlays ====

# Add an ''EMF Feature Overlay'' to display the current pan angle of the camera on the top left corner of the view:
## Create a ''Variable Feature Reference'', set the ''Variable'' to '''myAssembly''';
## Create a ''Type'' referring to ''camera'';
## Create a ''Feature'' chain referring to ''currentPanAngle'';
# Add a ''Gray Scale Filter'' to ''myCameraViewConfig'';
# Create a call named '''moveToPanTilt''' to operation ''moveToPanTilt(...)'' on ''myAssembly:camera'';
# Call ''acquireImage'' on ''camera'' to get the image to update;
# Call ''moveToPanTilt'' on ''camera'' to change the camera orientation;
# Call ''acquireImage'' again on ''camera'' to get the image to update. 

=== Setting Up & Using The Map View ===

==== Displaying The Environment ====

# Create a ''Map View Configuration List'' under ''Tools'';
# Create a ''Map View Configuration'' named '''myMapConfig''';
# Create an ''Image Map Layer Presentation'' referring to '''myContours'';
# Create a ''Feature Of Interest Map Layer Presentation'' referring to '''myFOI''';
# Open the ''Map View'' and select '''myMapConfig'''.

==== Displaying The Variables ====

# Create a ''Vehicle Variable Annotation'' referring to '''myRover''';
# Create a ''Variable Trajectory Annotation'':
## Create a ''Default Trajectory Provider'' as its child;
## Assign its ''Variable'' to '''myRover'';
## Close the Map View;
## Open the Map View and select '''myMapConfig'''.

=== Setting Up & Using The ''Telemetry View'' ===

==== Defining Watches ====

# Under ''Tools'', create a ''Watches List Container'';
# Under ''Watches List Container'', create a ''Watches List'' named '''Test''';
# Under '''Test''', create a ''Watch'' named '''armWatch''', assign its ''Variable'' to '''myAssembly'''
# Under '''armWatch''', create a ''Type Member Reference Tree'' referring to '''arm''';
# Under '''armWatch''', create a ''Type Root Node'' and set its ''Source Class'' to '''RoboticArm''';
# Create a chain of ''Tree Feature Nodes'' to finally refer to '''elbowAngle''' 

==== Defining Displays ====

# Under ''Tools'', create a new ''Displays'';
# Under ''Displays'', create a ''Display List'' named '''armDisplays''';
# Under '''armDisplays''', create a ''Text Display'' with its ''Abstract Feature Node'' referring to '''elbowAngle''';
# Under '''armDisplays''', create a ''Number Vs. Time Plot Display'' with its ''Abstract Feature Node'' referring to '''elbowAngle''', with its ''height'' set to '''200''' and its ''width'' set to '''200'''.
# Open the ''Telemetry View'' and select '''armDisplays'''.  

----

== Developing Your Own Custom Symphony Types ==

=== Creating & Symphonyzing your own Pan-Tilt Unit (PTU) Camera <i>System</i> ===

==== An Overview Of The Desired System ====
TODO!

==== 1. Creating the PTU Camera's EMF Meta-Model ====

===== i. Creating The Camera's EMF Model =====

# Create a new ''Xcore Project'' named '''<org_prefix>.ptu''', where <org_prefix> is replaced by an appropriate prefix for your organization.
# In the '''/model''' folder, create an Xcore model named '''ptu.xcore'''
# Copy the following to the start of the empty Xcore model, replacing <org_prefix> where required:

<code>
     @GenModel(prefix="PTUCamera",
       	      modelName="PTUCamera",
    	      childCreationExtenders="true",
               extensibleProviderFactory="true",
               multipleEditorPages="false",
               operationReflection="true",
               suppressGenModelAnnotations="false")
     @GenModel(modelDirectory="/<org_prefix>.ptu/src-generated")
     @GenModel(editDirectory="/<org_prefix>.ptu.edit/src-generated")

     package <org_prefix>.ptu
</code>

# Create the class hierarchy shown before (classes in blue);
# Save the '''ptu.xcore''' file.  This will trigger the code generation in both the '''<org_prefix>.ptu''' and '''<org_prefix>.ptu.edit''' plugins.

===== ii. Implementing the Required Methods =====

# Implement the following methods in ''<org_prefix>.ptu.impl.CameraImpl'':

{| border="1" cellpadding="2"
! Method
! Description
|-
| ''RectangularFieldOfView()'' '''getFov'''()
| Getter method for the ''fov'' attribute of the camera.  See the code provided.
|-
| ''boolean'' '''commandZoom'''(''double'' zoom)
| Configures the current zoom; this needs to update the FOV as well!  See the code provided.
|-
| ''double'' '''getMinimumZoom'''()
| Returns the minimum zoom factor.  Return '''1.0''';
|-
| ''double'' '''getMaximumZoom'''()
| Returns the maximum zoom factor.  Return '''10.0''';
|-
| ''RectangularFrustrumFieldOfView'' '''getFieldOfView'''()
| Method declared by ''AbstractCamera''.  Return '''getFov()''';
|}

# Implement the following methods in ''<org_prefix>.ptu.impl.CameraSimulatedImpl'':

{| border="1" cellpadding="2"
! Method
! Description
|-
| ''boolean'' '''initialize'''()
| Initialize the camera.  Just return '''true''';
|-
| ''ImageSnapshot'' '''takeSnapshot'''()
| Takes and returns an ''ImageSnapshot''. See the code provided.
|}

# Implement the following methods in ''<org_prefix>.ptu.impl.PTUCameraSimulatedImpl'':

{| border="1" cellpadding="2"
! Method
! Description
|-
| ''double'' '''getMaximumPanAngle'''()
| Returns the maximum pan angle ('''in radians''').  Just return '''170.0 degrees'''.
|-
| ''double'' '''getMinimumPanAngle'''()
| Returns the minimum pan angle ('''in radians''').  Just return '''-170.0 degrees'''.
|-
| ''double'' '''getMaximumTiltAngle'''()
| Returns the maximum tilt angle ('''in radians''').  Just return '''90.0 degrees'''.
|-
| ''double'' '''getMinimumTiltAngle'''()
| Returns the minimum tilt angle ('''in radians''').  Just return '''-45.0 degrees'''.
|-
| ''boolean'' '''moveToPan'''(''double'' panAngle)
| Checks the commanded pan angle, which is in '''radians'''.  If it's within range, update '''currentPan''' to the commanded value and return true; otherwise, return false.
|-
| ''boolean'' '''moveToTilt'''(''double'' tiltAngle)
| Checks the commanded tilt angle, which is in '''radians'''.  If it's within range, update '''currentTilt''' to the commanded value and return true; otherwise, return false. 
|-
| ''boolean'' '''moveToPanTilt'''(''double'' panAngle, ''double'' tiltAngle)
| Checks the commanded pan and tilt angles, both of which are in '''radians'''.  If they are within range, update both '''currentPan''' and '''currentTilt''' to the commanded values and return true; otherwise, return false.
|-
| ''boolean'' '''moveByPan'''(''double'' panAngleDelta)
| Checks the sum of '''currentPan''' and the commanded pan angle offset (given in '''radians''').  If the resulting pan angle is in range, update '''currentPan''' to the resultant value and return true; otherwise, return false. 
|-
| ''boolean'' '''moveByTilt'''(''double'' tiltAngleDelta)
| Checks the sum of '''currentTilt'''and the commanded tilt angle offset (given in '''radians''').  If the resulting tilt angle is in range, update '''currentTilt''' to the resultant value and return true; otherwise, return false. 
|-
| ''boolean'' '''moveByPanTilt'''(''double'' panAngleDelta, ''double'' tiltAngleDelta)
| Checks the sum of '''currentPan''' and the commanded pan angle offset (given in '''radians''') as well as the sum of '''currentTilt''' and the commanded tilt angle offset (given in '''radians''').  If both resulting angles are in range, update both '''currentPan''' and '''currentTilt''' to the resultant values and return true; otherwise, return false.
|-
| ''boolean'' '''stopMotion'''()
| Stops all motion.  Just return true.
|}

===== iii. Testing the System =====

# Create a new ''Eclipse Application'' under ''Run Configuration''. Name it '''TEST''';
# Click ''Run'' to launch another instance of Eclipse with your plugins;
# In the ''Project Explorer View'', create a new Symphony Project (by clicking on ''New > Other... > Symphony > New Symphony Project'').  Name it '''my_tests''';
# Create a new Symphony Session named '''MySession.sym''' in the newly create project.
# In the ''Types'', under ''Local'', create a ''Type'' named '''PTUCamera''';
# Set the type's ''Interface Class'' to ''<org_prefix>.ptu.PTUCamera'';
# Under ''Variables'', create a ''Variable'' named '''ptuCamera''' and specify its type as '''PTUCamera''';
# In the '''Default''' ''Context'', add a ''Variable Implementation'' that maps variable '''ptuCamera''' to a ''<org_prefix>.ptu.SimulatedPTUCamera'' implementation;
# Select the ''Symphony Environment'' and right-click, selecting ''Symphony > Reset Instances'' to initialize instances;
# Under ''Programs'', create an ''Operation Call List'' named '''ptuCmd''';
# Under ''ptuCmd'', create an ''Operation Call'' named '''Init'' referencing ''ptuCamera.initialize()'';
# Invoke the '''Init''' ''Operation Call'' and verify that the command has been executed;
# Under ''ptuCmd'', create an ''Operation Call'' named '''MoveTo''' referencing ''ptuCamera.moveToPanTilt(...)'', with a '''pan''' ''Parameter'' of '''45.0''' degrees and a '''tilt''' ''Parameter'' of '''-30.0''' degrees; 
# Invoke the '''MoveTo''' ''Operation Call'' and verify that the command has been executed;
# Under ''ptuCmd'', create an ''Operation Call'' named '''Zoom''' referencing ''ptuCamera.commandZoom(...)'', with a '''zoom''' ''Parameter'' of '''2.0''';
# Invoke the '''Zoom''' ''Operation Call'' and verify that the command has been executed;
# Under ''ptuCmd'', create an ''Operation Call'' named '''SnapShot''' referencing ''ptuCamera.takeSnapshot()''
# Invoke the '''SnapShot''' ''Operation Call'' and verify that the command has been executed.

==== 2. Creating the PTU Camera's Symphony Plugin ====

===== i. Creating The Camera's Plugin Project =====

# Create a new ''Xcore Project'' named '''<org_prefix>.ptu.symphony''';
# Open the '''MANIFEST.MF'''.  Go to the ''Dependencies'' tab;
# In the ''Required Plug-ins'' section:
## Add your ''<org_prefix>.ptu'' plugin to the dependencies;
## Add the ''org.eclipse.symphony.core'' plugin to the dependencies;
# Save the '''MANIFEST.MF'''

===== ii. Developing the Camera's Symphony Xcore (.xcore) model =====

# Rename the '''/src-gen''' folder to '''/src-generated''';
# In the '''/model''' folder, copy over the provided file '''ptu_symphony.xcore''';
# Replace the <org_prefix> in the model with the appropriate name:
## Ensure that you change the '''modelDirectory''' @GenModel directive to <org_prefix>.ptu.symphony'''/src-generated'''
## Ensure that you change the '''editDirectory''' @GenModel directive to <org_prefix>.ptu.symphony.edit'''/src-generated'''

===== iii. Specializing <i>SymphonyInitializationData</i> for the Camera =====

# Open the '''ptu_symphony.xcore''' model;
# Define a new class named '''''PTUCameraSymphonyInitializationData''''' that extends ''SymphonyInitializationData'';
# Add the required attributes:
## ''double'' '''panAngle''';
## ''double'' '''tiltAngle''';
## ''double'' '''zoomFactor''' (with a default value of '''1.0''')
# Save the '''ptu_symphony.xcore''' model.

===== iv. Specializing <i>SymphonySystemApiAdapter</i> for the Camera =====

# Open the '''ptu_symphony.xcore''' model;
# Define a new class named '''''PTUCameraSymphonySystemApiAdapter''''' that extends ''SymphonySystemApiAdapter''';
# Save the ''ptu_symphony.xcore'' model;
# Override the following methods in '''''PTUCameraSymphonySystemApiAdapterImpl''''':

{| border="1" cellpadding="2"
! Method
! Description
! Implementation
|-
| ''AbstractInitializationData'' '''createInitializationData'''()
| Creates an instance of ''SymphonyInitializationData''.
| Returns a new instance of ''PTUCameraSymphonyInitializationData''.
|-
| void '''collect'''(''AbstractInitializationData'')
| Sets the attributes of the given ''SymphonyInitializationData'' object to match the System's state.
| Gets the current value of '''pan''', '''tilt''', and '''zoom''' from the System instance and sets these in the provided ''PTUCameraSymphonyInitializationData''.
|-
| void '''apply'''(''AbstractInitializationData'')
| Applies the given ''SymphonyInitializationData'' to the System instance.
| Gets the '''pan''' and '''tilt''' from the given ''PTUCameraSymphonyInitializationData'' object and calls '''moveToPanTilt'''('''pan''', '''tilt'''); then gets the '''zoom'' and calls '''commandZoom'''('''zoom'''). 
|-
| ''Matrix4x4'' '''createResultMatrix'''(''OperationCall'')
| Creates the ''Matrix4x4'' used to position the result of an ''Operation Call'' relative to the System's origin.
| See the code provided.
|}

==== 3. Creating the PTU Camera's Complete <i>Symphony System Model</i> ====

===== i.Creating the Camera's <i>Symphony System Model</i> (.ss file) =====

# Launch the ''Run Configuration'' used for testing ''PTUCamera'' in the previous exercises;
# In the ''Project Explorer'', right click and then select ''Import...'';
# In the ''Import'' pop-up, select ''General -> Existing Projects into Workspace'', then click ''Next >'';
# Select your workspace root directory; the ''Projects'' list will get populated with your plugins. ''De-select'' all of them, except '''<org_prefix>.ptu.symphony''';
# Click ''Finish''.  You now have a reference to your Symphony plugin in your new Eclipse instance;
# Create a Symphony System Model named '''MyPTUCameraSymphonySystem.ss''' in the '''/model''' folder of your '''<org_prefix>.ptu.symphony''' plugin (use the ''New Symphony System'' wizard plugin);
# Set the name of the Symphony System Model to '''MyPTUCameraSymphonySystem''';
# Set the ''Interface Class'' to '''<org_prefix>.ptu.PTUCamera''';
# Set the ''Type Api Adapter Class'' to '''<org_prefix>.ptu.symphony.PTUCameraSymphonySystemApiAdapter''';
# Save the model (*.ss) file.

===== ii. Specifying the Camera's Topology =====

====== Target Topology Hierarchy ======

The desired final topology for ''MyPTUCameraSymphonySystem'' should be as follows:

TODO!

Note:
* Create the nodes and set their ID / description right away; this makes it much easier to both understand and navigate the topology.
* URLs in ''URLNodes'' should have the following format:
: ''platform:/plugin/'''<org_prefix>.ptu.symphony/cadmodels'''/filename.ext'' 

====== Target Transformations ======

The desired final transformation for the components of ''MyPTUCameraSymphonySystem'' should be as follows:

TODO!

====== Creating the CAD folder ======

# In your '''<org_prefix>.ptu.symphony''' plugin, create a folder '''/cadmodels'''.  This folder will hold the CAD files containing the geometry of your System;
# Copy the CAD files provided to the '''/cadmodels''' folder
# Open the '''MANIFEST.MF''' for your '''<org_prefix>.ptu.symphony''' plugin;
# Go to the ''Build'' tab;
# In the ''Binary Build'' section, select the '''/cadmodels''' folder; this will ensure that it will be included in the binary plugin when installed.
# Save the '''MANIFEST.MF'''

====== Populating the topology ======

# Launch the ''Run Configuration'' used for testing the ''PTUCamera'' in the previous exercises;
# Open your '''PTUCameraSymphonySystem.ss'' file with the editor;
# Open the ''Symphony System 3D Viewer, then select the ''Symphony System'' in the editor;
# Under ''Topology Root'', create the topology for the ''PTUCamera'', replicating the structure specified in '''Target Topology Hierarchy''' above;
# For the relevant transformations in the new hierarchy, update their position and orientation to reflect those specified in '''Target Transformations''' above;
# Save the file.

===== iii. Making the Camera's Bindings =====

====== Defining the <i>Feature Nodes</i> ======

# Open your '''PTUCameraSymphonySystem.ss''' file with the editor 
# Under ''Binding Sets -> Feature Roots List'', create a new ''Tree Root Node'', select it and set its ''Source Class'' to '''<org_prefix>.ptu.PTUCamera''';
# Under the new ''Tree Root Node'', create three new ''Tree Feature Nodes'':
## Set the ''Structural Feature'' for the first to '''currentPanAngle''';
## Set the ''Structural Feature'' for the second to '''currentTiltAngle''';
## Set the ''Structural Feature'' for the third to '''fov''';
# Save the Symphony System Model (*.ss) file;

====== Making the Bindings themselves ======

# Open your '''PTUCameraSymphonySystem.ss''' file with the editor
# Under ''Binding Sets-> Bindings List'', create the following ''Rotation Bindings'':

{| border="1" cellpadding="2"
! Name
! Feature Node
! Rotation Units
! Rotation Node
! Rotation Axis
|-
| Pan Angle
| ''currentPanAngle''
| ''RADIANS''
| ''PTU_CAMERA_PAN_JOINT''
| ''Z_AXIS''
|- 
| Rotation Angle
| ''currentTiltAngle''
| ''RADIANS''
| ''PTU_CAMERA_TILT_JOINT''
| ''MINUS_Y_AXIS''
|}

# Similarly, create the following ''Rectangular Frustrum Field Of View Binding'':

{| border="1" cellpadding="2"
! Name
! Feature Node
! Field Of View (FOV) Node
|-
| FOV
| ''fov''
| ''PTU_CAMERA_FOV''
|}

# Save the .ss file

===== iv. Registering the Camera's <i>Symphony System Model</i> =====

# Open the '''MANIFEST.MF''' of your '''<org_prefix>.ptu.symphony''' plugin;
# In the ''Extensions'' tab, click ''Add...'';
# Ensure the ''Show only extension points from the required plug-ins'' is '''NOT''' selected;
# Select the '''org.eclipse.symphony.core.invocator.typeContributor''';
# Click ''Finish'';
# Select the newly added extension and then click on ''Browse'' for the '''URI''' field;
# Browse to your Symphony System Model ('''MyPTUCameraSymphonySystem.ss''') file and then click ''OK'';
# Save the '''MANIFEST.MF'''

==== 4. Testing the completed PTU Camera in Symphony ====

# Launch the ''Run Configuration'' used for testing the ''PTUCamera'' in the previous exercises;
# Open '''MySession.sym''';
# Expand ''Session -> Symphony Environment -> Types -> Registered'': the '''MyPTUCameraSymphonySystem''' should be present;
# Open the ''Symphony 3D Viewer'', then select the ''Symphony Environment''; this will make the ''3D Viewer'' display your environment;
# Under ''Symphony Environment'', create a new ''Worksites'';
# Under ''Worksites'', create a new ''Earth Surface Worksite'';
# Set the '''Active Worksite''' of the ''Symphony Environment'' to the new ''Earth Surface Worksite'';
# Select the '''ptuCamera''' ''Variable'' and set its ''Variable Type'' to ''MyPTUCameraSymphonySystem'';
# Reset Instances: Your ''PTUCamera'' should appear in the 3D Viewer;
# Invoke the ''Operation Calls'' defined in the previous exercises and confirm that the ''System'' responds correctly;
# Done!

